--- a/include/net/cfg80211.h	2008-02-28 19:54:52.000000000 +0100
+++ b/include/net/cfg80211.h	2008-02-28 19:54:53.000000000 +0100
@@ -5,6 +5,7 @@
 #include <linux/skbuff.h>
 #include <linux/nl80211.h>
 #include <net/genetlink.h>
+#include <net/compat.h>
 
 /*
  * 802.11 configuration in-kernel interface
--- a/net/wireless/sysfs.c	2008-02-28 19:54:52.000000000 +0100
+++ b/net/wireless/sysfs.c	2008-02-28 19:54:53.000000000 +0100
@@ -52,6 +52,7 @@ static void wiphy_dev_release(struct dev
 	cfg80211_dev_free(rdev);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 #ifdef CONFIG_HOTPLUG
 static int wiphy_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
@@ -59,15 +60,18 @@ static int wiphy_uevent(struct device *d
 	return 0;
 }
 #endif
+#endif
 
 struct class ieee80211_class = {
 	.name = "ieee80211",
 	.owner = THIS_MODULE,
 	.dev_release = wiphy_dev_release,
 	.dev_attrs = ieee80211_dev_attrs,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 #ifdef CONFIG_HOTPLUG
 	.dev_uevent = wiphy_uevent,
 #endif
+#endif
 };
 
 int wiphy_sysfs_init(void)
--- a/include/linux/ssb/ssb.h	2008-02-28 19:54:52.000000000 +0100
+++ b/include/linux/ssb/ssb.h	2008-02-28 19:54:53.000000000 +0100
@@ -9,6 +9,7 @@
 #include <linux/mod_devicetable.h>
 
 #include <linux/ssb/ssb_regs.h>
+#include <net/compat.h>
 
 
 struct pcmcia_device;
--- a/net/ieee80211/ieee80211_module.c	2008-02-28 19:54:52.000000000 +0100
+++ b/net/ieee80211/ieee80211_module.c	2008-02-28 19:54:53.000000000 +0100
@@ -47,7 +47,9 @@
 #include <linux/wireless.h>
 #include <linux/etherdevice.h>
 #include <asm/uaccess.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 #include <net/net_namespace.h>
+#endif
 #include <net/arp.h>
 
 #include <net/ieee80211.h>
--- a/net/mac80211/cfg.c	2008-02-28 19:54:52.000000000 +0100
+++ b/net/mac80211/cfg.c	2008-02-28 19:54:53.000000000 +0100
@@ -9,7 +9,9 @@
 #include <linux/ieee80211.h>
 #include <linux/nl80211.h>
 #include <linux/rtnetlink.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 #include <net/net_namespace.h>
+#endif
 #include <linux/rcupdate.h>
 #include <net/cfg80211.h>
 #include "ieee80211_i.h"
--- a/drivers/ssb/scan.c	2008-02-28 19:54:52.000000000 +0100
+++ b/drivers/ssb/scan.c	2008-02-28 19:54:53.000000000 +0100
@@ -392,10 +392,18 @@ int ssb_bus_scan(struct ssb_bus *bus,
 				/* Ignore PCI cores on PCI-E cards.
 				 * Ignore PCI-E cores on PCI cards. */
 				if (dev->id.coreid == SSB_DEV_PCI) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+					if (compat_is_pcie(bus->host_pci))
+#else
 					if (bus->host_pci->is_pcie)
+#endif
 						continue;
 				} else {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+					if (!compat_is_pcie(bus->host_pci))
+#else
 					if (!bus->host_pci->is_pcie)
+#endif
 						continue;
 				}
 			}
--- a/net/wireless/Makefile	2008-02-28 19:54:52.000000000 +0100
+++ b/net/wireless/Makefile	2008-02-28 19:54:53.000000000 +0100
@@ -1,5 +1,4 @@
-obj-$(CONFIG_WIRELESS_EXT) += wext.o
 obj-$(CONFIG_CFG80211) += cfg80211.o
 
-cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o
+cfg80211-y += core.o sysfs.o radiotap.o util.o reg.o compat.o
 cfg80211-$(CONFIG_NL80211) += nl80211.o
--- a/drivers/net/usb/Makefile	2008-02-28 19:54:52.000000000 +0100
+++ b/drivers/net/usb/Makefile	2008-02-28 19:54:53.000000000 +0100
@@ -2,21 +2,7 @@
 # Makefile for USB Network drivers
 #
 
-obj-$(CONFIG_USB_CATC)		+= catc.o
-obj-$(CONFIG_USB_KAWETH)	+= kaweth.o
-obj-$(CONFIG_USB_PEGASUS)	+= pegasus.o
-obj-$(CONFIG_USB_RTL8150)	+= rtl8150.o
-obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
-obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
-obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
-obj-$(CONFIG_USB_NET_GL620A)	+= gl620a.o
-obj-$(CONFIG_USB_NET_NET1080)	+= net1080.o
-obj-$(CONFIG_USB_NET_PLUSB)	+= plusb.o
 obj-$(CONFIG_USB_NET_RNDIS_HOST)	+= rndis_host.o
-obj-$(CONFIG_USB_NET_CDC_SUBSET)	+= cdc_subset.o
-obj-$(CONFIG_USB_NET_ZAURUS)	+= zaurus.o
-obj-$(CONFIG_USB_NET_MCS7830)	+= mcs7830.o
-obj-$(CONFIG_USB_USBNET)	+= usbnet.o
 
 ifeq ($(CONFIG_USB_DEBUG),y)
 EXTRA_CFLAGS += -DDEBUG
--- a/drivers/net/wireless/Makefile	2008-03-11 19:54:52.000000000 +0100
+++ b/drivers/net/wireless/Makefile	2008-03-11 19:54:53.000000000 +0100
@@ -6,48 +6,13 @@ obj-$(CONFIG_IPW2100) += ipw2100.o
 
 obj-$(CONFIG_IPW2200) += ipw2200.o
 
-obj-$(CONFIG_STRIP) += strip.o
-obj-$(CONFIG_ARLAN) += arlan.o 
-
-arlan-objs := arlan-main.o arlan-proc.o
-
-# Obsolete cards
-obj-$(CONFIG_WAVELAN)		+= wavelan.o
-obj-$(CONFIG_PCMCIA_NETWAVE)	+= netwave_cs.o
-obj-$(CONFIG_PCMCIA_WAVELAN)	+= wavelan_cs.o
-
-obj-$(CONFIG_HERMES)		+= orinoco.o hermes.o
-obj-$(CONFIG_PCMCIA_HERMES)	+= orinoco_cs.o
-obj-$(CONFIG_APPLE_AIRPORT)	+= airport.o
-obj-$(CONFIG_PLX_HERMES)	+= orinoco_plx.o
-obj-$(CONFIG_PCI_HERMES)	+= orinoco_pci.o
-obj-$(CONFIG_TMD_HERMES)	+= orinoco_tmd.o
-obj-$(CONFIG_NORTEL_HERMES)	+= orinoco_nortel.o
-obj-$(CONFIG_PCMCIA_SPECTRUM)	+= spectrum_cs.o
-
-obj-$(CONFIG_AIRO)		+= airo.o
-obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
-
-obj-$(CONFIG_ATMEL)             += atmel.o
-obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
-obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
-
 obj-$(CONFIG_USB_ATMEL)	        += at76_usb.o
-
-obj-$(CONFIG_PRISM54)		+= prism54/
-
-obj-$(CONFIG_HOSTAP)		+= hostap/
 obj-$(CONFIG_B43)		+= b43/
 obj-$(CONFIG_B43LEGACY)		+= b43legacy/
 obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
 
-# 16-bit wireless PCMCIA client drivers
-obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
-obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
-
 obj-$(CONFIG_USB_NET_RNDIS_WLAN)	+= rndis_wlan.o
 
-obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
 obj-$(CONFIG_LIBERTAS)		+= libertas/
 
 rtl8180-objs		:= rtl8180_dev.o rtl8180_rtl8225.o rtl8180_sa2400.o rtl8180_max2820.o rtl8180_grf5101.o
--- a/net/wireless/nl80211.c	2008-06-11 13:10:36.000000000 -0700
+++ b/net/wireless/nl80211.c	2008-06-11 13:10:37.000000000 -0700
@@ -1065,7 +1065,7 @@
 			return -ENODEV;
 		if (!(*vlan)->ieee80211_ptr)
 			return -EINVAL;
-		if ((*vlan)->ieee80211_ptr->wiphy != &rdev->wiphy)
+		if (((struct wireless_dev *)(*vlan)->ieee80211_ptr)->wiphy != &rdev->wiphy)
 			return -EINVAL;
 	}
 	return 0;
--- a/drivers/net/wireless/zd1211rw/zd_chip.c	2008-03-07 20:02:06.000000000 -0500
+++ b/drivers/net/wireless/zd1211rw/zd_chip.c	2008-03-07 20:02:07.000000000 -0500
@@ -1281,7 +1281,7 @@
 	other_led = chip->link_led == LED1 ? LED2 : LED1;
 
 	switch (status) {
-	case LED_OFF:
+	case LED_OFF_ZD:
 		ioreqs[0].value = FW_LINK_OFF;
 		ioreqs[1].value = v[1] & ~(LED1|LED2);
 		break;
--- a/drivers/net/wireless/zd1211rw/zd_chip.h	2008-03-07 20:02:06.000000000 -0500
+++ b/drivers/net/wireless/zd1211rw/zd_chip.h	2008-03-07 20:02:07.000000000 -0500
@@ -897,7 +897,7 @@
 int zd_chip_unlock_phy_regs(struct zd_chip *chip);
 
 enum led_status {
-	LED_OFF = 0,
+	LED_OFF_ZD = 0,
 	LED_SCANNING = 1,
 	LED_ASSOCIATED = 2,
 };
--- a/net/mac80211/util.c	2008-06-04 00:38:14.000000000 -0700
+++ b/net/mac80211/util.c	2008-06-08 07:31:57.000000000 -0700
@@ -20,11 +20,20 @@
 #include <linux/if_arp.h>
 #include <linux/wireless.h>
 #include <linux/bitmap.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 #include <net/net_namespace.h>
+#endif
 #include <net/cfg80211.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
 #include <net/rtnetlink.h>
+#else
+#include <linux/rtnetlink.h>
+#endif
 
 #include "ieee80211_i.h"
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+#include "mq_compat.h"
+#endif
 #include "rate.h"
 #include "mesh.h"
 #include "wme.h"
@@ -331,7 +340,14 @@
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
+/* 2.6.22 doesn't have CONFIG_NETDEVICES_MULTIQUEUE so lets not make use
+ * of queues_pending map and use our own old hack */
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+	if (test_and_clear_bit(IEEE80211_LINK_STATE_XOFF,
+		&local->state[queue])) {
+#else
 	if (test_bit(queue, local->queues_pending)) {
+#endif
 		tasklet_schedule(&local->tx_pending_tasklet);
 	} else {
 		if (ieee80211_is_multiqueue(local)) {
--- a/drivers/net/wireless/libertas/dev.h	2008-04-15 19:25:05.000000000 -0700
+++ b/drivers/net/wireless/libertas/dev.h	2008-04-15 19:28:16.000000000 -0700
@@ -11,6 +11,7 @@
 #include <linux/ethtool.h>
 #include <linux/debugfs.h>
 #include <net/ieee80211.h>
+#include <net/compat.h>
 
 #include "defs.h"
 #include "hostcmd.h"
--- a/drivers/ssb/main.c	2008-04-15 19:25:05.000000000 -0700
+++ b/drivers/ssb/main.c	2008-04-15 19:25:05.000000000 -0700
@@ -347,6 +347,27 @@
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+static int ssb_device_uevent(struct device *dev, char **envp,
+	int num_envp, char *buffer, int buffer_size)
+{
+	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
+	int cur_index = 0, cur_len = 0;
+
+	if (!dev)
+		return -ENODEV;
+
+	return add_uevent_var(envp,
+			num_envp,
+			&cur_index,
+			buffer,
+			buffer_size,
+			&cur_len,
+			"MODALIAS=ssb:v%04Xid%04Xrev%02X",
+			ssb_dev->id.vendor, ssb_dev->id.coreid,
+			ssb_dev->id.revision);
+}
+#else
 static int ssb_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
@@ -359,6 +380,7 @@
 			     ssb_dev->id.vendor, ssb_dev->id.coreid,
 			     ssb_dev->id.revision);
 }
+#endif
 
 static struct bus_type ssb_bustype = {
 	.name		= "ssb",
--- a/drivers/net/wireless/ath5k/hw.c	2008-04-24 12:20:11.000000000 -0700
+++ b/drivers/net/wireless/ath5k/hw.c	2008-04-24 12:20:12.000000000 -0700
@@ -349,7 +349,11 @@
 	 * I guess these point to ClockReq but
 	 * i'm not sure.)
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+	if ((ah->ah_version == AR5K_AR5212) && compat_is_pcie(pdev)) {
+#else
 	if ((ah->ah_version == AR5K_AR5212) && (pdev->is_pcie)) {
+#endif
 		ath5k_hw_reg_write(ah, 0x9248fc00, 0x4080);
 		ath5k_hw_reg_write(ah, 0x24924924, 0x4080);
 		ath5k_hw_reg_write(ah, 0x28000039, 0x4080);
@@ -496,7 +500,11 @@
 	/* reseting PCI on PCI-E cards results card to hang
 	 * and always return 0xffff... so we ingore that flag
 	 * for PCI-E cards */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+	bus_flags = (compat_is_pcie(pdev)) ? 0 : AR5K_RESET_CTL_PCI;
+#else
 	bus_flags = (pdev->is_pcie) ? 0 : AR5K_RESET_CTL_PCI;
+#endif
 
 	/* Reset chipset */
 	ret = ath5k_hw_nic_reset(ah, AR5K_RESET_CTL_PCU |
@@ -1049,7 +1057,11 @@
 	 * TODO: Check out tx triger level, it's always 64 on dumps but I
 	 * guess we can tweak it and see how it goes ;-)
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+	dma_size = (compat_is_pcie(pdev)) ? AR5K_DMASIZE_128B : AR5K_DMASIZE_512B;
+#else
 	dma_size = (pdev->is_pcie) ? AR5K_DMASIZE_128B : AR5K_DMASIZE_512B;
+#endif
 	if (ah->ah_version != AR5K_AR5210) {
 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
 			AR5K_TXCFG_SDMAMR, dma_size);
--- a/include/linux/bitops.h	2008-05-15 06:51:10.000000000 -0700
+++ b/include/linux/bitops.h	2008-05-15 07:04:23.000000000 -0700
@@ -1,14 +1,17 @@
 #ifndef _LINUX_BITOPS_H
 #define _LINUX_BITOPS_H
 #include <asm/types.h>
+#include <linux/version.h>
 
 #ifdef	__KERNEL__
 #define BIT(nr)			(1UL << (nr))
 #define BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_LONG))
 #define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
 #define BITS_PER_BYTE		8
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23))
 #define BITS_TO_LONGS(nr)	DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
 #endif
+#endif
 
 /*
  * Include this here because some architectures need generic_ffs/fls in
--- a/drivers/misc/Makefile	2008-05-15 07:10:28.000000000 -0700
+++ b/drivers/misc/Makefile	2008-05-15 07:13:18.000000000 -0700
@@ -3,26 +3,4 @@
 #
 obj- := misc.o	# Dummy rule to force built-in.o to be made
 
-obj-$(CONFIG_IBM_ASM)		+= ibmasm/
-obj-$(CONFIG_HDPU_FEATURES)	+= hdpuftrs/
-obj-$(CONFIG_MSI_LAPTOP)     += msi-laptop.o
-obj-$(CONFIG_ACER_WMI)     += acer-wmi.o
-obj-$(CONFIG_ASUS_LAPTOP)	+= asus-laptop.o
-obj-$(CONFIG_EEEPC_LAPTOP)	+= eeepc-laptop.o
-obj-$(CONFIG_ATMEL_PWM)		+= atmel_pwm.o
-obj-$(CONFIG_ATMEL_SSC)		+= atmel-ssc.o
-obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib.o
-obj-$(CONFIG_TC1100_WMI)	+= tc1100-wmi.o
-obj-$(CONFIG_LKDTM)		+= lkdtm.o
-obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
-obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
-obj-$(CONFIG_PHANTOM)		+= phantom.o
-obj-$(CONFIG_SGI_IOC4)		+= ioc4.o
-obj-$(CONFIG_SONY_LAPTOP)	+= sony-laptop.o
-obj-$(CONFIG_THINKPAD_ACPI)	+= thinkpad_acpi.o
-obj-$(CONFIG_FUJITSU_LAPTOP)	+= fujitsu-laptop.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
-obj-$(CONFIG_INTEL_MENLOW)	+= intel_menlow.o
-obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
-obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
-obj-$(CONFIG_SGI_XP)		+= sgi-xp/
--- a/net/wireless/core.c	2008-05-15 07:15:18.000000000 -0700
+++ b/net/wireless/core.c	2008-05-15 07:15:19.000000000 -0700
@@ -71,9 +71,9 @@
 		ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);
 		dev = dev_get_by_index(&init_net, ifindex);
 		if (dev) {
-			if (dev->ieee80211_ptr)
+			if (((struct wireless_dev *)dev->ieee80211_ptr))
 				byifidx =
-					wiphy_to_dev(dev->ieee80211_ptr->wiphy);
+					wiphy_to_dev(((struct wireless_dev *)dev->ieee80211_ptr)->wiphy);
 			dev_put(dev);
 		}
 		err = -ENODEV;
@@ -123,8 +123,8 @@
 	dev = dev_get_by_index(&init_net, ifindex);
 	if (!dev)
 		goto out;
-	if (dev->ieee80211_ptr) {
-		drv = wiphy_to_dev(dev->ieee80211_ptr->wiphy);
+	if (((struct wireless_dev *)dev->ieee80211_ptr)) {
+		drv = wiphy_to_dev(((struct wireless_dev *)dev->ieee80211_ptr)->wiphy);
 		mutex_lock(&drv->mtx);
 	} else
 		drv = ERR_PTR(-ENODEV);
@@ -368,28 +368,28 @@
 	struct net_device *dev = ndev;
 	struct cfg80211_registered_device *rdev;
 
-	if (!dev->ieee80211_ptr)
+	if (!((struct wireless_dev *)dev->ieee80211_ptr))
 		return 0;
 
-	rdev = wiphy_to_dev(dev->ieee80211_ptr->wiphy);
+	rdev = wiphy_to_dev(((struct wireless_dev *)dev->ieee80211_ptr)->wiphy);
 
 	switch (state) {
 	case NETDEV_REGISTER:
 		mutex_lock(&rdev->devlist_mtx);
-		list_add(&dev->ieee80211_ptr->list, &rdev->netdev_list);
+		list_add(&((struct wireless_dev *)dev->ieee80211_ptr)->list, &rdev->netdev_list);
 		if (sysfs_create_link(&dev->dev.kobj, &rdev->wiphy.dev.kobj,
 				      "phy80211")) {
 			printk(KERN_ERR "wireless: failed to add phy80211 "
 				"symlink to netdev!\n");
 		}
-		dev->ieee80211_ptr->netdev = dev;
+		((struct wireless_dev *)dev->ieee80211_ptr)->netdev = dev;
 		mutex_unlock(&rdev->devlist_mtx);
 		break;
 	case NETDEV_UNREGISTER:
 		mutex_lock(&rdev->devlist_mtx);
-		if (!list_empty(&dev->ieee80211_ptr->list)) {
+		if (!list_empty(&((struct wireless_dev *)dev->ieee80211_ptr)->list)) {
 			sysfs_remove_link(&dev->dev.kobj, "phy80211");
-			list_del_init(&dev->ieee80211_ptr->list);
+			list_del_init(&((struct wireless_dev *)dev->ieee80211_ptr)->list);
 		}
 		mutex_unlock(&rdev->devlist_mtx);
 		break;
--- a/drivers/net/wireless/libertas/ethtool.c	2008-05-20 22:04:10.000000000 -0700
+++ b/drivers/net/wireless/libertas/ethtool.c	2008-05-20 22:06:48.000000000 -0700
@@ -111,6 +111,7 @@
 	lbs_deb_enter(LBS_DEB_ETHTOOL);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 static int lbs_ethtool_get_sset_count(struct net_device *dev, int sset)
 {
 	struct lbs_private *priv = dev->priv;
@@ -120,6 +121,7 @@
 
 	return -EOPNOTSUPP;
 }
+#endif
 
 static void lbs_ethtool_get_strings(struct net_device *dev,
 				    uint32_t stringset, uint8_t *s)
@@ -187,7 +189,9 @@
 	.get_drvinfo = lbs_ethtool_get_drvinfo,
 	.get_eeprom =  lbs_ethtool_get_eeprom,
 	.get_eeprom_len = lbs_ethtool_get_eeprom_len,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 	.get_sset_count = lbs_ethtool_get_sset_count,
+#endif
 	.get_ethtool_stats = lbs_ethtool_get_stats,
 	.get_strings = lbs_ethtool_get_strings,
 	.get_wol = lbs_ethtool_get_wol,
--- a/drivers/net/wireless/adm8211.h	2008-05-23 11:55:04.000000000 +0530
+++ b/drivers/net/wireless/adm8211.h	2008-05-23 11:55:05.000000000 +0530
@@ -416,8 +416,13 @@
 #define TDES1_CONTROL_RBS1	(0x00000fff)
 
 /* SRAM offsets */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+#define ADM8211_SRAM(x) (priv->revid < ADM8211_REV_BA ? \
+        ADM8211_SRAM_A_ ## x : ADM8211_SRAM_B_ ## x)
+#else
 #define ADM8211_SRAM(x) (priv->pdev->revision < ADM8211_REV_BA ? \
         ADM8211_SRAM_A_ ## x : ADM8211_SRAM_B_ ## x)
+#endif
 
 #define ADM8211_SRAM_INDIV_KEY   0x0000
 #define ADM8211_SRAM_A_SHARE_KEY 0x0160
@@ -565,6 +570,9 @@
 	u8 lnags_threshold;
 	struct adm8211_eeprom *eeprom;
 	size_t eeprom_len;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	u8 revid;
+#endif
 
 	u32 nar;
 
--- a/drivers/net/wireless/adm8211.c	2008-05-23 11:55:04.000000000 +0530
+++ b/drivers/net/wireless/adm8211.c	2008-05-23 11:55:05.000000000 +0530
@@ -143,7 +143,11 @@
 		break;
 
 	default:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		if (priv->revid < ADM8211_REV_CA)
+#else
 		if (priv->pdev->revision < ADM8211_REV_CA)
+#endif
 			priv->rf_type = ADM8211_TYPE_RFMD;
 		else
 			priv->rf_type = ADM8211_TYPE_AIROHA;
@@ -161,7 +165,11 @@
 	case ADM8211_TYPE_ADMTEK:
 		break;
 	default:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		if (priv->revid < ADM8211_REV_CA)
+#else
 		if (priv->pdev->revision < ADM8211_REV_CA)
+#endif
 			priv->bbp_type = ADM8211_TYPE_RFMD;
 		else
 			priv->bbp_type = ADM8211_TYPE_ADMTEK;
@@ -201,7 +209,11 @@
 		break;
 
 	default:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		if (priv->revid < ADM8211_REV_CA)
+#else
 		if (priv->pdev->revision < ADM8211_REV_CA)
+#endif
 			priv->specific_bbptype = ADM8211_BBP_RFMD3000;
 		else
 			priv->specific_bbptype = ADM8211_BBP_ADM8011;
@@ -220,11 +232,23 @@
 		break;
 
 	default:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		if (priv->revid == ADM8211_REV_BA)
+#else
 		if (priv->pdev->revision == ADM8211_REV_BA)
+#endif
 			priv->transceiver_type = ADM8211_RFMD2958_RF3000_CONTROL_POWER;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		else if (priv->revid == ADM8211_REV_CA)
+#else
 		else if (priv->pdev->revision == ADM8211_REV_CA)
+#endif
 			priv->transceiver_type = ADM8211_AL2210L;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		else if (priv->revid == ADM8211_REV_AB)
+#else
 		else if (priv->pdev->revision == ADM8211_REV_AB)
+#endif
 			priv->transceiver_type = ADM8211_RFMD2948;
 
 		printk(KERN_WARNING "%s (adm8211): Unknown transceiver: %d\n",
@@ -246,7 +270,11 @@
 	struct adm8211_priv *priv = dev->priv;
 
 	ADM8211_CSR_WRITE(WEPCTL, addr | ADM8211_WEPCTL_TABLE_WR |
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+			(priv->revid < ADM8211_REV_BA ?
+#else
 			  (priv->pdev->revision < ADM8211_REV_BA ?
+#endif
 			   0 : ADM8211_WEPCTL_SEL_WEPTABLE ));
 	ADM8211_CSR_READ(WEPCTL);
 	msleep(1);
@@ -264,7 +292,11 @@
 	u32 reg = ADM8211_CSR_READ(WEPCTL);
 	unsigned int i;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	if (priv->revid < ADM8211_REV_BA) {
+#else
 	if (priv->pdev->revision < ADM8211_REV_BA) {
+#endif
 		for (i = 0; i < len; i += 2) {
 			u16 val = buf[i] | (buf[i + 1] << 8);
 			adm8211_write_sram(dev, addr + i / 2, val);
@@ -443,7 +475,11 @@
 		if (skb) {
 			struct ieee80211_rx_status rx_status = {0};
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+			if (priv->revid < ADM8211_REV_CA)
+#else
 			if (priv->pdev->revision < ADM8211_REV_CA)
+#endif
 				rx_status.signal = rssi;
 			else
 				rx_status.signal = 100 - rssi;
@@ -716,7 +752,11 @@
 		adm8211_rf_write_syn_rfmd2958(dev, 0x0A, reg);
 		/* set TXRX TX_GAIN */
 		adm8211_rf_write_syn_rfmd2958(dev, 0x09, 0x00050 |
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+			(priv->revid < ADM8211_REV_CA ? tx_power : 0));
+#else
 			(priv->pdev->revision < ADM8211_REV_CA ? tx_power : 0));
+#endif
 	} else {
 		reg = ADM8211_CSR_READ(PLCPHD);
 		reg &= 0xff00ffff;
@@ -735,7 +775,11 @@
 				  tx_power<<2);
 	adm8211_write_bbp(dev, RF3000_LOW_GAIN_CALIB, lpf_cutoff);
 	adm8211_write_bbp(dev, RF3000_HIGH_GAIN_CALIB, lnags_thresh);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	adm8211_write_bbp(dev, 0x1c, priv->revid == ADM8211_REV_BA ?
+#else
 	adm8211_write_bbp(dev, 0x1c, priv->pdev->revision == ADM8211_REV_BA ?
+#endif
 				     priv->eeprom->cr28 : 0);
 	adm8211_write_bbp(dev, 0x1d, priv->eeprom->cr29);
 
@@ -774,7 +818,11 @@
 		priv->nar |= ADM8211_NAR_EA | ADM8211_NAR_ST | ADM8211_NAR_SR;
 
 		/* don't trust the error bits on rev 0x20 and up in adhoc */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		if (priv->revid >= ADM8211_REV_BA)
+#else
 		if (priv->pdev->revision >= ADM8211_REV_BA)
+#endif
 			priv->soft_rx_crc = 1;
 		break;
 	case IEEE80211_IF_TYPE_MNTR:
@@ -875,7 +923,11 @@
 			break;
 		}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+		switch (priv->revid) {
+#else
 		switch (priv->pdev->revision) {
+#endif
 		case ADM8211_REV_CA:
 			if (priv->transceiver_type == ADM8211_RFMD2958 ||
 			    priv->transceiver_type == ADM8211_RFMD2958_RF3000_CONTROL_POWER ||
@@ -933,7 +985,11 @@
 			adm8211_write_bbp(dev, 0x1c, 0x00);
 			adm8211_write_bbp(dev, 0x1d, 0x80);
 		} else {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+			if (priv->revid == ADM8211_REV_BA)
+#else
 			if (priv->pdev->revision == ADM8211_REV_BA)
+#endif
 				adm8211_write_bbp(dev, 0x1c, priv->eeprom->cr28);
 			else
 				adm8211_write_bbp(dev, 0x1c, 0x00);
@@ -1065,7 +1121,11 @@
 	u8 rate_buf[12] = {0};
 
 	/* write supported rates */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	if (priv->revid != ADM8211_REV_BA) {
+#else
 	if (priv->pdev->revision != ADM8211_REV_BA) {
+#endif
 		rate_buf[0] = ARRAY_SIZE(adm8211_rates);
 		for (i = 0; i < ARRAY_SIZE(adm8211_rates); i++)
 			rate_buf[i + 1] = (adm8211_rates[i].bitrate / 5) | 0x80;
@@ -1149,7 +1209,11 @@
 	 * PWR0PE2  = 13 us
 	 * PWR1PE2  = 1 us
 	 * PWR0TXPE = 8 or 6 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	if (priv->revid < ADM8211_REV_CA)
+#else
 	if (priv->pdev->revision < ADM8211_REV_CA)
+#endif
 		ADM8211_CSR_WRITE(TOFS2, 0x8815cd18);
 	else
 		ADM8211_CSR_WRITE(TOFS2, 0x8535cd16);
@@ -1178,7 +1242,11 @@
 
 	/* SLOT=20 us, SIFS=110 cycles of 22 MHz (5 us),
 	 * DIFS=50 us, EIFS=100 us */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	if (priv->revid < ADM8211_REV_CA)
+#else
 	if (priv->pdev->revision < ADM8211_REV_CA)
+#endif
 		ADM8211_CSR_WRITE(IFST, (20 << 23) | (110 << 15) |
 					(50 << 9)  | 100);
 	else
@@ -1237,13 +1305,21 @@
 
 	ADM8211_CSR_WRITE(PAR, tmp);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	if (priv->revid == ADM8211_REV_BA &&
+#else
 	if (priv->pdev->revision == ADM8211_REV_BA &&
+#endif
 	    (priv->transceiver_type == ADM8211_RFMD2958_RF3000_CONTROL_POWER ||
 	     priv->transceiver_type == ADM8211_RFMD2958)) {
 		reg = ADM8211_CSR_READ(CSR_TEST1);
 		reg |= (1 << 4) | (1 << 5);
 		ADM8211_CSR_WRITE(CSR_TEST1, reg);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	} else if (priv->revid == ADM8211_REV_CA) {
+#else
 	} else if (priv->pdev->revision == ADM8211_REV_CA) {
+#endif
 		reg = ADM8211_CSR_READ(CSR_TEST1);
 		reg &= ~((1 << 4) | (1 << 5));
 		ADM8211_CSR_WRITE(CSR_TEST1, reg);
@@ -1876,6 +1952,9 @@
 		       pci_name(pdev));
 		goto err_iounmap;
 	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &priv->revid);
+#endif
 
 	*(__le32 *)perm_addr = cpu_to_le32(ADM8211_CSR_READ(PAR0));
 	*(__le16 *)&perm_addr[4] =
@@ -1905,7 +1984,11 @@
 	priv->mode = IEEE80211_IF_TYPE_INVALID;
 
 	/* Power-on issue. EEPROM won't read correctly without */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	if (priv->revid >= ADM8211_REV_BA) {
+#else
 	if (pdev->revision >= ADM8211_REV_BA) {
+#endif
 		ADM8211_CSR_WRITE(FRCTL, 0);
 		ADM8211_CSR_READ(FRCTL);
 		ADM8211_CSR_WRITE(FRCTL, 1);
@@ -1933,7 +2016,11 @@
 
 	printk(KERN_INFO "%s: hwaddr %s, Rev 0x%02x\n",
 	       wiphy_name(dev->wiphy), print_mac(mac, dev->wiphy->perm_addr),
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+	       priv->revid);
+#else
 	       pdev->revision);
+#endif
 
 	return 0;
 
--- a/drivers/net/wireless/zd1211rw/zd_mac.c	2008-05-23 11:55:04.000000000 +0530
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c	2008-05-23 11:55:05.000000000 +0530
@@ -984,5 +984,5 @@
 	dev_dbg_f(zd_mac_dev(mac), "\n");
 	cancel_rearming_delayed_workqueue(zd_workqueue,
 		&mac->housekeeping.link_led_work);
-	zd_chip_control_leds(&mac->chip, LED_OFF);
+	zd_chip_control_leds(&mac->chip, LED_OFF_ZD);
 }
--- a/net/mac80211/rx.c	2008-05-23 11:55:04.000000000 +0530
+++ b/net/mac80211/rx.c	2008-05-23 11:55:05.000000000 +0530
@@ -308,8 +308,13 @@
 		}
 
 		prev_dev = sdata->dev;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+		sdata->stats.rx_packets++;
+		sdata->stats.rx_bytes += skb->len;
+#else
 		sdata->dev->stats.rx_packets++;
 		sdata->dev->stats.rx_bytes += skb->len;
+#endif
 	}
 
 	if (prev_dev) {
@@ -1400,8 +1405,13 @@
 
 	skb->dev = dev;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+	IEEE80211_DEV_TO_SUB_IF(dev)->stats.rx_packets++;
+	IEEE80211_DEV_TO_SUB_IF(dev)->stats.rx_bytes += skb->len;
+#else
 	dev->stats.rx_packets++;
 	dev->stats.rx_bytes += skb->len;
+#endif
 
 	/* skip the wrapping header */
 	eth = (struct ethhdr *) skb_pull(skb, sizeof(struct ethhdr));
@@ -1510,8 +1520,13 @@
 
 	rx->skb->dev = dev;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+	rx->sdata->stats.rx_packets++;
+	rx->sdata->stats.rx_bytes += rx->skb->len;
+#else
 	dev->stats.rx_packets++;
 	dev->stats.rx_bytes += rx->skb->len;
+#endif
 
 	ieee80211_deliver_skb(rx);
 
@@ -1717,8 +1732,13 @@
 		}
 
 		prev_dev = sdata->dev;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+		sdata->stats.rx_packets++;
+		sdata->stats.rx_bytes += skb->len;
+#else
 		sdata->dev->stats.rx_packets++;
 		sdata->dev->stats.rx_bytes += skb->len;
+#endif
 	}
 
 	if (prev_dev) {
--- a/net/mac80211/iface.c	2008-05-23 14:02:26.000000000 +0530
+++ b/net/mac80211/iface.c	2008-05-23 14:11:06.000000000 +0530
@@ -53,6 +53,15 @@
 	if (!ndev)
 		return -ENOMEM;
 
+
+	/* 2.6.26 added ndev->needed_headroom and dev->needed_tailroom.
+	 * Then commit SHA1
+	 * f5184d267c1aedb9b7a8cc44e08ff6b8d382c3b5
+	 * added LL_ALLOCATED_SPACE and made most users of 
+	 * LL_RESERVED_SPACE make use LL_ALLOCATED_SPACE instead. We
+	 * let the old kernels through as they still are using
+	 * LL_ALLOCATED_SPACE */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
 	ndev->needed_headroom = local->tx_headroom +
 				4*6 /* four MAC addresses */
 				+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */
@@ -61,6 +70,7 @@
 				- ETH_HLEN /* ethernet hard_header_len */
 				+ IEEE80211_ENCRYPT_HEADROOM;
 	ndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;
+#endif
 
 	ret = dev_alloc_name(ndev, ndev->name);
 	if (ret < 0)
--- a/net/mac80211/tx.c	2008-06-04 00:38:14.000000000 -0700
+++ b/net/mac80211/tx.c	2008-06-08 06:03:45.000000000 -0700
@@ -18,12 +18,17 @@
 #include <linux/etherdevice.h>
 #include <linux/bitmap.h>
 #include <linux/rcupdate.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 #include <net/net_namespace.h>
+#endif
 #include <net/ieee80211_radiotap.h>
 #include <net/cfg80211.h>
 #include <net/mac80211.h>
 #include <asm/unaligned.h>
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+#include "mq_compat.h" /* Internal MQ backport support for older kernels */
+#endif
 #include "ieee80211_i.h"
 #include "led.h"
 #include "mesh.h"
@@ -213,6 +218,7 @@
 	return dur;
 }
 
+
 static int inline is_ieee80211_device(struct net_device *dev,
 				      struct net_device *master)
 {
@@ -665,8 +671,12 @@
 	 * etc.
 	 */
 	if (WARN_ON(tx->flags & IEEE80211_TX_CTL_AMPDU ||
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+			IEEE80211_SKB_CB(tx->skb)->queue >= tx->local->hw.queues))
+#else
 		    skb_get_queue_mapping(tx->skb) >=
 			ieee80211_num_regular_queues(&tx->local->hw)))
+#endif
 		return TX_DROP;
 
 	first = tx->skb;
@@ -1095,8 +1105,9 @@
 	u16 queue;
 
 	queue = skb_get_queue_mapping(skb);
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23))
 	WARN_ON(test_bit(queue, local->queues_pending));
+#endif
 
 	if (unlikely(skb->len < 10)) {
 		dev_kfree_skb(skb);
@@ -1174,7 +1185,12 @@
 
 		if (ret == IEEE80211_TX_FRAG_AGAIN)
 			skb = NULL;
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+		set_bit(IEEE80211_LINK_STATE_PENDING, &local->state[queue]);
+#else
 		set_bit(queue, local->queues_pending);
+#endif
 		smp_mb();
 		/*
 		 * When the driver gets out of buffers during sending of
@@ -1188,7 +1204,12 @@
 		 * possible to have happened.
 		 */
 		if (!__netif_subqueue_stopped(local->mdev, queue)) {
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+			clear_bit(IEEE80211_LINK_STATE_PENDING,
+				&local->state[queue]);
+#else
 			clear_bit(queue, local->queues_pending);
+#endif
 			goto retry;
 		}
 		store->skb = skb;
@@ -1613,8 +1634,13 @@
 	info->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
 
 	skb->dev = local->mdev;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+	sdata->stats.tx_packets++;
+	sdata->stats.tx_bytes += skb->len;
+#else
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
+#endif
 
 	/* Update skb pointers to various headers since this modified frame
 	 * is going to go through Linux networking code that may potentially
@@ -1646,14 +1672,24 @@
 	struct ieee80211_tx_stored_packet *store;
 
 	for (i = 0; i < ieee80211_num_regular_queues(&local->hw); i++) {
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+		/* XXX: Test this */
+		//if (__ieee80211_queue_stopped(local, i))
+		if (0)
+#else
 		if (!test_bit(i, local->queues_pending))
+#endif
 			continue;
 		store = &local->pending_packet[i];
 		kfree_skb(store->skb);
 		for (j = 0; j < store->num_extra_frag; j++)
 			kfree_skb(store->extra_frag[j]);
 		kfree(store->extra_frag);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+		clear_bit(IEEE80211_LINK_STATE_PENDING, &local->state[i]);
+#else
 		clear_bit(i, local->queues_pending);
+#endif
 	}
 }
 
@@ -1674,8 +1710,11 @@
 		/* Check that this queue is ok */
 		if (__netif_subqueue_stopped(local->mdev, i))
 			continue;
-
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+		if (!__ieee80211_queue_pending(local, i)) {
+#else
 		if (!test_bit(i, local->queues_pending)) {
+#endif
 			ieee80211_wake_queue(&local->hw, i);
 			continue;
 		}
@@ -1692,7 +1731,12 @@
 			if (ret == IEEE80211_TX_FRAG_AGAIN)
 				store->skb = NULL;
 		} else {
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+			clear_bit(IEEE80211_LINK_STATE_PENDING,
+				&local->state[i]);
+#else
 			clear_bit(i, local->queues_pending);
+#endif
 			ieee80211_wake_queue(&local->hw, i);
 		}
 	}
--- a/net/mac80211/ieee80211_i.h	2008-06-04 00:38:14.000000000 -0700
+++ b/net/mac80211/ieee80211_i.h	2008-06-08 05:49:26.000000000 -0700
@@ -406,6 +406,10 @@
 
 	struct wireless_dev wdev;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+	struct net_device_stats stats;
+#endif
+
 	/* keys */
 	struct list_head key_list;
 
@@ -532,7 +536,7 @@
 	return container_of(p, struct ieee80211_sub_if_data, vif);
 }
 
-#define IEEE80211_DEV_TO_SUB_IF(dev) netdev_priv(dev)
+#define IEEE80211_DEV_TO_SUB_IF(dev) ((struct ieee80211_sub_if_data *)netdev_priv(dev))
 
 enum {
 	IEEE80211_RX_MSG	= 1,
@@ -589,7 +593,14 @@
 	struct sta_info *sta_hash[STA_HASH_SIZE];
 	struct timer_list sta_cleanup;
 
+/* Kernels without CONFIG_NETDEVICES_MULTIQUEUE (<=2.6.22) need this, so
+ * we implement multiple queue support internally with mac80211 hacks. */
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+	unsigned long state[IEEE80211_MAX_QUEUES + IEEE80211_MAX_AMPDU_QUEUES];
+#else
 	unsigned long queues_pending[BITS_TO_LONGS(IEEE80211_MAX_QUEUES)];
+#endif
+
 	struct ieee80211_tx_stored_packet pending_packet[IEEE80211_MAX_QUEUES];
 	struct tasklet_struct tx_pending_tasklet;
 
--- a/net/mac80211/main.c	2008-06-11 13:10:36.000000000 -0700
+++ b/net/mac80211/main.c	2008-06-11 13:10:37.000000000 -0700
@@ -21,7 +21,9 @@
 #include <linux/wireless.h>
 #include <linux/rtnetlink.h>
 #include <linux/bitmap.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 #include <net/net_namespace.h>
+#endif
 #include <net/cfg80211.h>
 
 #include "ieee80211_i.h"
@@ -960,6 +962,13 @@
 	.cache_update	= eth_header_cache_update,
 };
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+static struct net_device_stats *ieee80211_get_stats(struct net_device *dev)
+{
+	return &IEEE80211_DEV_TO_SUB_IF(dev)->stats;
+}
+#endif
+
 /* Must not be called for mdev */
 void ieee80211_if_setup(struct net_device *dev)
 {
@@ -971,6 +980,9 @@
 	dev->open = ieee80211_open;
 	dev->stop = ieee80211_stop;
 	dev->destructor = ieee80211_if_free;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+	dev->get_stats = ieee80211_get_stats;
+#endif
 }
 
 /* everything else */
@@ -1677,7 +1689,12 @@
 	mdev->open = ieee80211_master_open;
 	mdev->stop = ieee80211_master_stop;
 	mdev->type = ARPHRD_IEEE80211;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+	mdev->get_stats = ieee80211_get_stats;
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 	mdev->header_ops = &ieee80211_header_ops;
+#endif
 	mdev->set_multicast_list = ieee80211_master_set_multicast_list;
 
 	sdata->vif.type = IEEE80211_IF_TYPE_AP;
--- a/include/net/mac80211.h	2008-06-04 00:38:13.000000000 -0700
+++ b/include/net/mac80211.h	2008-06-09 01:25:08.000000000 -0700
@@ -293,7 +293,11 @@
 	s8 tx_rate_idx;
 	u8 antenna_sel_tx;
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+	u8 queue; /* For compatibilty support for HT for kernels <= 2.6.22 */
+#else
 	/* 1 byte hole */
+#endif
 
 	union {
 		struct {
@@ -323,6 +327,20 @@
 	return (struct ieee80211_tx_info *)skb->cb;
 }
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+/* Added was added as of 2.6.24 in include/linux/skbuff.h, this for old kernels,
+ * we put it here instead of compat.h as we don't want to rely on mac80211.h in
+ * compat.h */
+static inline u16 skb_get_queue_mapping(struct sk_buff *skb)
+{
+	return IEEE80211_SKB_CB(skb)->queue;
+}
+
+static inline void skb_set_queue_mapping(struct sk_buff *skb, u16 queue_mapping)
+{
+	IEEE80211_SKB_CB(skb)->queue = queue_mapping;
+}
+#endif
 
 /**
  * enum mac80211_rx_flags - receive flags
--- a/net/mac80211/wme.c	2008-06-09 02:06:22.000000000 -0700
+++ b/net/mac80211/wme.c	2008-06-09 02:09:30.000000000 -0700
@@ -17,6 +17,9 @@
 #include <net/mac80211.h>
 #include "ieee80211_i.h"
 #include "wme.h"
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22))
+#include "mq_compat.h"
+#endif
 
 /* maximum number of hardware queues we support. */
 #define QD_MAX_QUEUES (IEEE80211_MAX_AMPDU_QUEUES + IEEE80211_MAX_QUEUES)
@@ -328,14 +331,22 @@
 
 
 /* called whenever parameters are updated on existing qdisc */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+static int wme_qdiscop_tune(struct Qdisc *qd, struct rtattr *opt)
+#else
 static int wme_qdiscop_tune(struct Qdisc *qd, struct nlattr *opt)
+#endif
 {
 	return 0;
 }
 
 
 /* called during initial creation of qdisc on device */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+static int wme_qdiscop_init(struct Qdisc *qd, struct rtattr *opt)
+#else
 static int wme_qdiscop_init(struct Qdisc *qd, struct nlattr *opt)
+#endif
 {
 	struct ieee80211_sched_data *q = qdisc_priv(qd);
 	struct net_device *dev = qd->dev;
@@ -456,7 +467,11 @@
 
 
 static int wme_classop_change(struct Qdisc *qd, u32 handle, u32 parent,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+				struct rtattr **tca, unsigned long *arg)
+#else
 			      struct nlattr **tca, unsigned long *arg)
+#endif
 {
 	unsigned long cl = *arg;
 	struct ieee80211_local *local = wdev_priv(qd->dev->ieee80211_ptr);
@@ -540,7 +555,11 @@
 
 /* this qdisc is classful (i.e. has classes, some of which may have leaf qdiscs attached)
  * - these are the operations on the classes */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+static struct Qdisc_class_ops class_ops =
+#else
 static const struct Qdisc_class_ops class_ops =
+#endif
 {
 	.graft = wme_classop_graft,
 	.leaf = wme_classop_leaf,
