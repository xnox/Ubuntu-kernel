#!/usr/bin/python
#==============================================================================
# Author: Stefan Bader <stefan.bader@canonical.com>
# Copyright (C) 2010
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#==============================================================================
import sys, os
import optparse
from cvescripts_lib import *
from buildenv_lib import *

parser = optparse.OptionParser()
dsc = "Save current work in progress (extracts patches, updates tracker)"
parser.set_description(dsc)
parser.add_option("--no-tracker-push", action="store_false",
		  dest="trackerpush", default=True,
		  help="Do not push changes to CVE tracker after committing.")
(opt, args) = parser.parse_args()

#------------------------------------------------------------------------------
# First make sure there is a link named "current-item" which points to the
# cve-tracker data.
#------------------------------------------------------------------------------
workdir = os.getcwd()
workfile = os.path.join(workdir, "current-item")
if not os.path.islink(workfile):
	print "EE: Link {0} not found or not a symbolic link".format(workfile)
	sys.exit(1)
if not os.path.isfile(workfile):
	print "EE: Link {0} does not point to a file".format(workfile)
	sys.exit(1)

#------------------------------------------------------------------------------
# Load workitem data.
#------------------------------------------------------------------------------
wi = WorkItem(workfile)
winame = wi.get_candidate()

#------------------------------------------------------------------------------
# Get the save directory (will be created)
#------------------------------------------------------------------------------
savedir = GetSaveDir(winame)

#------------------------------------------------------------------------------
# Verify that the work repositories are clean.
#------------------------------------------------------------------------------
print "II: Verifying whether all workareas are clean..."
if not IsWorkareaClean(branch=winame):
	print "EE: Will not save until workarea has been cleaned"
	sys.exit(1)

#------------------------------------------------------------------------------
# Now walk through all workareas and extract the patches
#------------------------------------------------------------------------------
print "II: Extracting patches..."
for area in ListWorkareas():
	areaprinted = False
	patchdir = os.path.join(GetPatchDir(winame), area)
	AssertDir(patchdir, verbose=False)
	#----------------------------------------------------------------------
	# Remove the files currently in patchdir (not to gather dead entries).
	#----------------------------------------------------------------------
	for file in os.listdir(patchdir):
		if file.split(".")[-1] == "txt":
			os.unlink(os.path.join(patchdir, file))
	#----------------------------------------------------------------------
	# Export all patches since the branch was split off.
	#----------------------------------------------------------------------
	os.chdir(os.path.join(workdir, area))
	mergebase = GitMergeBase("ubuntu/master", winame)
	if not mergebase:
		print "EE: Failed to find a mergebase for", area
		sys.exit(1)
	cmd  = "git format-patch --suffix=.txt -o " + patchdir
	cmd += " " + mergebase
	for line in Popen(cmd, shell=True, stdout=PIPE).stdout:
		if not areaprinted:
			print "II:", area
			areaprinted = True
		print "II:", os.path.basename(line.strip())
	#----------------------------------------------------------------------
	# While we are there and there are patches, push the branch.
	#----------------------------------------------------------------------
	if areaprinted:
		print "II: Updating personal security repo."
		cmd = "git push -q origin +" + winame
		os.system(cmd)
	os.chdir(workdir)

#------------------------------------------------------------------------------
# Now update the workitem with the patches and current status.
#------------------------------------------------------------------------------
for area in ListWorkareas():
	series, pkgshort = area.split(os.path.sep, 1)
	pkg = PkgList[series][pkgshort]
	patchdir = os.path.join(GetPatchDir(winame), area)

	#----------------------------------------------------------------------
	# Remove all patches currently defined for this series/package. Those
	# will be re-added (or replaced by new ones) later.
	#----------------------------------------------------------------------
	if pkg in wi.list_packages() and wi.packages[pkg].has_key("Patches"):
		for patch in wi.packages[pkg]["Patches"]:
			if patch.startswith(series + ":"):
				wi.packages[pkg]["Patches"].remove(patch)

	#----------------------------------------------------------------------
	# Usually with the new model, all patches in the branch of a workitem
	# should be required to fix it. Just now I saw one case were a second
	# CVE is required to fix something introduced by another CVE which is
	# on the worklist, too. So the other patch is needed but should not be
	# part of the patches shown. Long story, short solution: only include
	# patches that have the right reference in them.
	#----------------------------------------------------------------------
	patches = sorted(os.listdir(patchdir))
	for patch in patches:
		found = 0
		patchfile = os.path.join(patchdir, patch)
		for line in open(patchfile, "r").readlines():
			if winame in line:
				found = 1
				break
		if not found:
			patches.remove(patch)

	#----------------------------------------------------------------------
	# Take any patches left and update the workitem with those.
	#----------------------------------------------------------------------
	if patches:
		if not pkg in wi.list_packages():
			print "WW: New package created", pkg
			wi.packages[pkg] = dict()
			wi.packages[pkg]["status"] = dict()
			wi.packages[pkg]["status"][series] = "needed"

		st = wi.get_status(pkg, series)
		if st in ["not-affected", "needs-triage", "needed"]:
			wi.set_status(pkg, series, "pending")
		for patch in patches:
			value = series + ": " + GetHttpLink(winame)
			value = os.path.join(value, "patches", area, patch)
			if not wi.packages[pkg].has_key("Patches"):
				wi.packages[pkg].setdefault("Patches", [])
			wi.packages[pkg]["Patches"].append(value)
	else:
		#--------------------------------------------------------------
		# This assumes that, when saving, any series without patches
		# is not affected.
		#--------------------------------------------------------------
		st = wi.get_status(pkg, series)
		if st == "pending":
			wi.set_status(pkg, series, "needed")
		if st == "needs-triage":
			wi.set_status(pkg, series, "not-affected")

#------------------------------------------------------------------------------
# This sends the patches to the public_html directory
#------------------------------------------------------------------------------
Publish(savedir)

#------------------------------------------------------------------------------
# Being optimistic, we create a backup of the
#------------------------------------------------------------------------------
ifile = open(workfile, "r")
ofile = open(os.path.basename(os.path.realpath(workfile)) + ".bak", "w")
for line in ifile.readlines():
	ofile.write(line)
ofile.close()
ifile.close()

#------------------------------------------------------------------------------
# Finally save the workitem and update the tracker. This will only cause a
# commit if there are really changes.
#------------------------------------------------------------------------------
wi.save(workfile)
TrackerCommit(winame + " updated with current work status",
	      push=opt.trackerpush)

