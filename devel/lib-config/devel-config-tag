#!/usr/bin/perl 
use strict;

if ($#ARGV != 1) {
	die "Usage: $0 <dump> <overrides>\n";
}

my ($dump, $overrides) = @ARGV;
my %options;
my %modenote;
my %desc;
my %choice_map;

my ($option, $maybe, $default, $expected, %flags, $prompt, @choices, $choice, $choice_map);
sub emit()
{
	if (!$choice && $#choices >= 0) {
		for my $opt (@choices) {
			$choice_map{$opt} = join(' ', @choices);
		}
		@choices = ();
	}

	return if (!$option || !$prompt);

	$expected = $default;

	if ($prompt =~ s/DEPRECATED//) {
		$flags{'DEPRECATED'} = 1;
	}
	if ($prompt =~ s/DANGEROUS//) {
		$flags{'DANGEROUS'} = 1;
	}
	if ($prompt =~ s/EXPERIMENTAL//) {
		$flags{'EXPERIMENTAL'} = 1;
	}
	$prompt =~ s/\s*$//;

	if ($flags{'EXPERIMENTAL'}) {
		# We default EXPERIMENTAL options off by default.
		my ($mode, $note) = ('n', '');

		if ($option =~ /^CONFIG_SENSORS_/ && $default eq 'm') {
			($mode, $note) = ('m', "sensors are opt-in");

		} elsif ($option =~ /^CONFIG_[^_]*_?FS$/ && $default eq 'm') {
			($mode, $note) = ('m', "filesystems are opt-in");

		} elsif ($option =~ /^CONFIG_[SP]ATA_/ && $default eq 'm') {
			($mode, $note) = ('m', "ATA drivers are opt-in");

		} elsif ($option =~ /^CONFIG_INPUT_/ && $default eq 'm') {
			($mode, $note) = ('m', "input drivers are opt-in");

		} elsif ($option =~ /^CONFIG_NETFILTER_XT_/ && $default eq 'm') {
			($mode, $note) = ('m', "netfilter targets are opt-in");

		} elsif ($option =~ /^CONFIG_HID_/ && $default eq 'm') {
			($mode, $note) = ('m', "HID drivers are opt-in");

		} elsif ($option =~ /^CONFIG_CRYPTO_/ && $default eq 'm') {
			($mode, $note) = ('m', "CRYPTO drivers are opt-in");

		} elsif ($option =~ /^CONFIG_VIDEO_/ && $default eq 'm') {
			($mode, $note) = ('m', "VIDEO drivers are opt-in");

		} elsif ($option =~ /^CONFIG_DRM_/ && $default eq 'm') {
			($mode, $note) = ('m', "DRM drivers are opt-in");

		} elsif ($option =~ /^CONFIG_DVB_/ && $default eq 'm') {
			($mode, $note) = ('m', "DVB drivers are opt-in");

		} elsif ($option =~ /^CONFIG_FB_/ && $default eq 'm') {
			($mode, $note) = ('m', "framebuffer drivers are opt-in");

		} elsif ($option =~ /^CONFIG_USB_/ && $default eq 'm') {
			($mode, $note) = ('m', "USB devices are opt-in");

		} elsif ($option =~ /^CONFIG_I2C/ && $default eq 'm') {
			($mode, $note) = ('m', "I2C devices are opt-in");
		}
		$note = "note<$note>" if ($note);
		$modenote{$option} = [$mode, $note] if ($mode ne 'n');
		($default, $expected) = ('n', 'n');
	}

	# CHOICE: pick one ...
	if ($choice) {
		($default, $expected) = ($default, 'c');
	}

	# DANGEROUS: clearly we do not want these enabled by default.
	if ($flags{'DANGEROUS'}) {
		($default, $expected) = ('n', 'n');
	}

	# DEPRECATED: clearly we do not want these enabled by default.
	if ($flags{'DEPRECATED'}) {
		($default, $expected) = ('n', 'n');
	}

	# DEBUG: clearly we do not want these enabled by default.
	if ($flags{'DEBUG'}) {
		($default, $expected) = ('n', 'n');
	}

	$options{$option} = join(' ', ($maybe, $default, $expected));
	for my $flag (sort keys %flags) {
		$options{$option} .= " flag<$flag>";
	}
	$desc{$option} = $prompt;

	# Reset for the next option ...
	($maybe, $default, $prompt, $choice) = ('-', '-', '', 0);
	undef %flags;
}
my ($note, $mode);
open(DUMP, "<$dump") || die "$0: $dump: open failed - $!\n";
while (<DUMP>) {
	chomp;

	# New record markers ...
	if (/^config\s(\S*)\s*$/) {
		emit();
		$option = "CONFIG_$1";

	} elsif (/^choice\s*$/) {
		emit();
		$option = '';
		@choices = ();

	} elsif (/^menu\s*$/) {
		emit();
		$option = '';

	} elsif (/^\s\s#choice value\s*$/) {
		$choice = 1;
		push(@choices, $option) if ($option);

	# Type specifiers ...
	} elsif (/^\s\sboolean\s*$/) {
		$maybe = "y/n";
		$default = 'y';

	} elsif (/^\s\stristate\s*$/) {
		$maybe = "y/m/n";
		$default = 'm';

	} elsif (/^\s\sstring\s*$/) {
		$maybe = '-';
		$default = '-';

	} elsif (/^\s\sinteger\s*$/) {
		$maybe = '-';
		$default = '-';

	# Description ...
	} elsif (/^\s\s(?:prompt|menu)\s"(.*)"\s*([^"]*)/) {
		my ($cond) = ($2);
		$prompt = $1;
		if ($cond =~ /\bSTAGING\b/) {
			$flags{'STAGING'} = 1;
		}
		if ($cond =~ /\bEXPERIMENTAL\b/) {
			$flags{'EXPERIMENTAL'} = 1;
		}
		if ($cond =~ /\bDEBUG_KERNEL\b/) {
			$flags{'DEBUG'} = 1;
		}

	# Dependancies ...           Defaults ...
	} elsif (/^\s\sdepends\s/ || /^\s\sdefault\s/) {
		if (/\bSTAGING\b/) {
			$flags{'STAGING'} = 1;
		}
		if (/\bEXPERIMENTAL\b/) {
			$flags{'EXPERIMENTAL'} = 1;
		}
		if (/\bDEBUG_KERNEL\b/) {
			$flags{'DEBUG'} = 1;
		}
	}

}
close(DUMP);
emit();

my @oa;
my ($mode, $note);
foreach my $key (sort keys %options) {
	($mode, $note) = ('', undef);

	@oa = split(' ', $options{$key});

	# We default DEBUG options off.
	if ($key =~ /_DEBUG(_FS$|_|$)/) {
		($mode, $note) = ('n', undef);
		$oa[2] = 'n';

	# NET_VENDOR_* represents vendor specific groupings, alway enable.
	} elsif ($oa[2] ne 'y' && $key =~ /^CONFIG_NET_VENDOR_/) {
		($mode, $note) = ('y', "VENDOR driver group always enabled");
	
	# *_PHY represent network PHY devices, always enable.
	#   http://marc.info/?l=linux-netdev&m=125700321922154&w=2
	} elsif ($key =~ /^CONFIG_.*_PHY$/ && $oa[2] eq 'm') {
		($mode, $note) = ('y', "PHY drivers are not autoloadable");
	
	# *_PARTITION_* represent partition table decoders
	} elsif ($key =~ /^CONFIG_.*_(PARTITION|DISKLABEL)$/) {
		($mode, $note) = ('y', "partition table decoders are not autoloadable");
	}

	$options{$key} = join(' ', @oa);
	if ($mode) {
		$note = "note<$note>" if ($note);
		$modenote{$key} = [$mode, $note];
	}
}

my @ea;
open(OVERRIDES, "<$overrides") ||
	die "$0: $overrides: open failed - $!\n";
while (<OVERRIDES>) {
	chomp;

	next if ($_ =~ /^$/ || $_ =~ /^#/);

	@ea = split(' ');

	@oa = split(' ', $options{$ea[0]});
	$oa[0] = '-' if ($oa[0] eq '');
	$oa[1] = '-' if ($oa[1] eq '');
	$oa[2] = '-' if ($oa[2] eq '');

	# Set the option to the specified value and add any other options
	$modenote{$ea[0]} = [$ea[1], join(' ', @ea[2..$#ea])];

	$options{$ea[0]} = join(' ', @oa);
}
close(OVERRIDES);

foreach my $key (sort keys %options) {
	if ($modenote{$key}) {
		($mode, $note) = @{$modenote{$key}};

		@oa = split(' ', $options{$key});
		if ($mode && $mode ne '-') {
			if ($mode ne 'p' && $oa[2] ne $mode && $note) {
				push(@oa, "flag<policy=$mode>");
			}
			$oa[2] = $mode;
		}
		push(@oa, $note) if ($note);
		$options{$key} = join(' ', @oa);
	}
	print "$key $options{$key} desc<$desc{$key}>";
	if ($choice_map{$key}) {
		print " choice<$choice_map{$key}>";
	}
	print "\n";

}
