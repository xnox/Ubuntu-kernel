#!/usr/bin/env python
#
# This script processes the "Jenkins Job Queue". This queue is a directory with
# file in it. Each file represents a newly built kernel that needs to be tested.
# This script goes through each file and creates the Jenkins job(s) that are
# needed to test that particular kernel.
#
# Note: There are some kernels that we do not test even though they appear in
#       the queue. This script handles those as well.
#

from os                                 import getenv, makedirs, path, listdir, remove
from logging                            import debug, info, error, basicConfig, DEBUG, WARNING, INFO
from lib.argparse                       import ArgumentParser
import json

from mako.template                      import Template
from mako.exceptions                    import RichTraceback

from aka_jenkins                        import Server, Nodes, Jobs

def info_j(obj):
    for line in json.dumps(obj, sort_keys=True, indent=4).split('\n'):
        info(line)

# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# Kernels
#
class Kernels():

    testable_arches = [
        'amd64',
        'i386'
    ]

    testable_kinds  = [
        'generic'
    ]

    info = {
        'hardy' : {
            'virt-profile-amd64' : 'virt-hardy-amd64',
            'virt-profile-i386'  : 'virt-hardy-i386',
        },

        'lucid' : {
            'virt-profile-amd64' : 'virt-lucid-amd64',
            'virt-profile-i386'  : 'virt-lucid-i386',
        },

        'natty' : {
            'virt-profile-amd64' : 'virt-natty-amd64',
            'virt-profile-i386'  : 'virt-natty-i386',
        },

        'oneiric' : {
            'virt-profile-amd64' : 'virt-oneiric-amd64',
            'virt-profile-i386'  : 'virt-oneiric-i386',
        },

        'precise' : {
            'virt-profile-amd64' : 'virt-precise-amd64',
            'virt-profile-i386'  : 'virt-precise-i386',
        },

        'quantal' : {
            'virt-profile-amd64' : 'virt-quantal-amd64',
            'virt-profile-i386'  : 'virt-quantal-i386',
        }
    }

    def base(self, version):
        pass

    @classmethod
    def is_testable_arch(cls, arch):
        return arch in cls.testable_arches

    @classmethod
    def is_testable_kind(cls, kind):
        return kind in cls.testable_kinds

# ProcKernelQueue
#
class ProcKernelQueue():

    # __init__
    #
    def __init__(self, args):
        self.cfg = args

        # Queue information about each kernel so that the test-job-builder
        # has the information it needs.
        #
        self.kernel_queue = 'queue'  # FIXME bjf - this needs to be moved either to
                                     #             the command line or to a config file.

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        return

    # load_entry
    #
    def load_entry(self, file_name):
        """
        Load the indicated json format file, returning the created object.
        """
        retval = None
        with open(file_name, 'r') as f:
            retval = json.load(f)

        return retval

    # load_template
    #
    def load_template(self, file_name):
        """
        Load the indicated mako template file. Return a mako Template()
        instance.
        """
        retval = None
        with open(file_name, 'r') as f:
            retval = Template(f.read())

        return retval

    def dequeue(self, record):
        remove(path.join(self.kernel_queue, record))
        info('dequeued  --  %s' % record)

    def jenkins_create_job(self, job_name, data):
        template = self.load_template('job-template.mako')
        job_xml = template.render(data=data)

        js = Server.jenkins
        js.create_job(job_name, job_xml)
        print(job_xml)
        info('created jenkins job: %s' % job_name)

    # main
    #
    def main(self):
        try:
            self.initialize()

            k = Kernels().info
            print(json.dumps(k, sort_keys=True, indent=4))

            # Looping through all the kernel queue entries:
            #
            for record in listdir(self.kernel_queue):
                info(record)

                kernel_entry = self.load_entry(path.join(self.kernel_queue, record))
                (kind, kernel_entry['kernel'], kernel_entry['series'], kernel_entry['arch']) = record.split(':')
                kernel_entry['kind'] = kind.replace('linux-image-', '')
                info_j(kernel_entry)

                # Figure out what kind of system we need to create.
                #
                # 1. Is this a kernel architecture we actually want to test. Kernels we don't want to test are
                #    sparc and ppc.
                #
                if not Kernels.is_testable_arch(kernel_entry['arch']):
                    info(record + '  --  ignored. (we don\'t test this arch: \'%s\')' % kernel_entry['arch'])
                    self.dequeue(record)
                    continue

                # 2. Is this the 'kind' of kernel that we want to test. We don't test 'extra' or 'virtual'
                #    kernel packages.
                #
                if not Kernels.is_testable_kind(kernel_entry['kind']):
                    info(record + '  --  ignored. (we don\'t test this kind: \'%s\')' % kernel_entry['kind'])
                    self.dequeue(record)
                    continue

                print(kernel_entry['arch'])
                print(kernel_entry['kind'])
                print(" ")

                jobs = []
                name = '%s-server' % (k[kernel_entry['series']]['virt-profile-%s' % kernel_entry['arch']])

                # Create the job: machine profile creation
                #
                if kernel_entry['arch'] == 'amd64':
                    distro = '%s-x86_64' % kernel_entry['series']
                else:
                    distro = '%s-i386' % kernel_entry['series']

                job_name = 'a__%s-profile-create' % (name)
                kickstart = '/var/lib/cobbler/kickstarts/u-s.preseed'
                ksmeta = 'hostname=%s' % name
                job_data = {
                    'description'      : 'Creates a machine profile which will be used by koan on the vm server to create a vm.',
                    'label expression' : 'kernel-orchestra-server',
                    'build steps'      : [
                        {
                            'kind' : 'shell',
                            'command' : 'sudo cobbler profile add --name=%s --distro=%s --kickstart=%s --ksmeta=%s --virt-file-size=20 --virt-ram=1000' % (name, distro, kickstart, ksmeta)
                        }
                    ]
                }
                self.jenkins_create_job(job_name, job_data)
                jobs.append(job_name)

                # Create the job: vm creation
                #
                job_name = 'a__%s-vm-create' % (name)
                job_data = {
                    'description'      : 'Creates a virtual machine for %s on the designated vm server using the kernel team orchestra server.',
                    'label expression' : 'kernel-vm-server',
                    'build steps'      : [
                        {
                            'kind' : 'shell',
                            'command' : 'sudo koan --virt --server=red --profile=%s --virt-name=%s --virt-bridge=br0 --vm-poll' % (name, name)
                        }
                    ]
                }
                self.jenkins_create_job(job_name, job_data)
                jobs.append(job_name)

                # Create the job: slave node
                #
                job_name = 'a__%s-slave-node' % (name)
                job_data = {
                    'description'      : 'Creates a slave node on the jenkins server that is associated with the vm that was created.',
                    'label expression' : 'master',
                    'build steps'      : [
                        {
                            'kind' : 'shell',
                            'command' : 'python /var/lib/jenkins/create-slave-node %s %s' % (name, name)
                        }
                    ]
                }
                self.jenkins_create_job(job_name, job_data)
                jobs.append(job_name)
                break


        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except Exit:
            pass

if __name__ == '__main__':
    if getenv('DEBUG'):
        LOGLEVEL = DEBUG
    else:
        LOGLEVEL = INFO
    basicConfig(level=LOGLEVEL, format="%(asctime)-15s-%(levelname)s - %(message)s", filename='/var/log/new-kernels-queue.log')
    info('Started')

    parser = ArgumentParser()
    parser.add_argument('-d', '--dry-run',  action='store_true', help='Don\'t actually perform the operations.')
    args = parser.parse_args()

    app = ProcKernelQueue(args)
    app.main()
    info('Stopped')

# vi:set ts=4 sw=4 expandtab:

