#!/usr/bin/env python
#

from sys                                import stdout, argv
from os                                 import path, unlink, _exit
from getopt                             import getopt, GetoptError
from datetime                           import datetime
import json
import re
import apt_pkg
import urllib
import atexit
import shutil
import time
from lpltk.service                      import LaunchpadService
from ktl.kernel                         import *
from ktl.archive                        import Archive

# stdo
#
# My own version of print but won't automatically add a linefeed to the end.
#
def stdo(ostr):
    stdout.write(ostr)
    stdout.flush()
    return

# StdApp
#
# Base class for all applications. This takes care of getting options from a
# configuration file in the user's home directory.
#
class StdApp:

    # __init__
    #
    def __init__(self):
        self.cfg = {}
        self.cfg['configuration_file'] = path.join(path.expanduser('~'), "sru.cfg")

    # __load_user_config
    #
    # If the users home directory contains a configuration file, load that in. The
    # name of the configuration file is '.kteam.rc'. The format of the file is
    # json. The json format should be an array. The contents of that array will
    # be merged with the default one 'self.cfg' in this class.
    #
    def __load_user_config(self):
        cfg_path = self.cfg['configuration_file']
        if path.exists(cfg_path):
            with open(cfg_path, 'r') as f:
                user_config = json.load(f)
            for k in user_config:
                self.cfg[k] = user_config[k]

    # merge_config_options
    #
    # 1. Defaults
    # 2. User config file overrides defaults
    # 3. Command line overrides user config and defaults
    #
    def merge_config_options(self, defaults, cmdline_options):
        for k in defaults:
            self.cfg[k] = defaults[k]

        if 'configuration_file' in cmdline_options:
            self.cfg['configuration_file'] = cmdline_options['configuration_file']
        if '~' in self.cfg['configuration_file']:
            self.cfg['configuration_file'] = self.cfg['configuration_file'].replace('~', path.expanduser('~'))

        self.__load_user_config()

        for k in cmdline_options:
            self.cfg[k] = cmdline_options[k]

        if ('debug' in self.cfg) and ('cfg' in self.cfg['debug']):
            stdo("Configuration:\n")
            stdo("-------------------------------------------------\n")
            for k in self.cfg:
                str = "%s" % (k)
                stdo('    %-25s = "%s"\n' % (str, self.cfg[k]))
            if 'exit' in self.cfg['debug']: _exit(0)

        return

    def dbg(self, system, msg):
        if 'debug' in self.cfg:
            if system in self.cfg['debug']:
                stdo("dbg: %s" % (msg))

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>] [--archive-versions]    \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("        --archive-versions                                                                   \n")
        stdo("                         Include all the version information for all the packages in         \n")
        stdo("                         the archive, in the output data.                                    \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        self.cfg['archive-versions'] = False
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=', 'archive-versions']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif opt in ('--archive-versions'):
                    self.cfg['archive-versions'] = True

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    self.cfg['source_pkgs'] = args

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return


# SruReport
#
class SruReport(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

        self.archive_root = 'http://archive.ubuntu.com/ubuntu'
        self.ports_root   = 'http://ports.ubuntu.com/ubuntu'

        self.components   = ['main', 'universe']
        self.release      = ['dapper', 'hardy', 'karmic', 'lucid', 'maverick']

        self.tempdir = None

    # initialize
    #
    def initialize(self):
        self.dbg('core', "initialize: enter\n")
        apt_pkg.init_system()
        # note that only 'LP: #1234' is official, but sometimes people get it wrong
        self.changelog_bug_pattern = re.compile('(?:lp:? ?#?|href="/bugs/)([0-9]+)')
        self.published_date_pattern = re.compile('Published.*\n.*on ([-0-9]+)')
        self.service = LaunchpadService()
        self.dbg('core', "initialize: leave\n")

        if self.cfg['archive-versions']:
            ar = Archive()
            self.ppa       = ar.ppa_versions(force=False)
            self.dversions = ar.distro_versions(force=False)

        return

    # decompress_open
    #
    def decompress_open(self, tagfile):
        if tagfile.startswith('http:') or tagfile.startswith('ftp:'):
            url = tagfile
            tagfile = urllib.urlretrieve(url)[0]
            atexit.register(unlink, tagfile)

        if tagfile.endswith('.gz'):
            import gzip
            import tempfile
            if not self.tempdir:
                self.tempdir = tempfile.mkdtemp(prefix='suite-diff')
                atexit.register(shutil.rmtree, self.tempdir, True)
            decompressed = tempfile.mktemp(dir=self.tempdir)
            fin = gzip.GzipFile(filename=tagfile)
            fout = open(decompressed, 'wb')
            fout.write(fin.read())
            fout.close()
            atexit.register(unlink, decompressed)
            return open(decompressed, 'r')
        else:
            return open(tagfile, 'r')

    # tagfile_to_dict
    #
    def tagfile_to_dict(self, tagfile):
        rls = {}
        p = apt_pkg.TagFile(self.decompress_open(tagfile))
        while p.step() == 1:
            rls[p.section["Package"]] = p.section["Version"]
        return rls

    # get_changelog_info
    #
    def get_changelog_info(self, url):
        '''Parse LP per-version/per-release page URL and return tuple (date, bugs)
        with a publishing date (time record) and a bug list string.'''

        # enable this for quick testing
        #return (time.localtime(), '')

        chlog = urllib.urlopen(url).read()

        m = self.published_date_pattern.search(chlog)
        if m:
            date = time.strptime(m.group(1), '%Y-%m-%d')
        else:
            # less than a day ago (Soyuz uses "... hours ago")
            date = time.localtime()

        # cut out the actual changelog
        chlog = chlog[chlog.find('<pre '):chlog.find('</pre>')]

        bugnums = []
        for m in self.changelog_bug_pattern.finditer(chlog):
            bug = m.group(1)
            if bug.startswith('#'):
                bug = bug[1:]
            if bug not in bugnums:
                bugnums.append(bug)

        return (date, bugnums)

    # main
    #
    def main(self):
        results = {}
        pending = {}             # suite -> package -> (release_ver, proposed_ver, update_ver)
        security_superseded = {} # suite -> package -> (proposed_ver, security_ver)
        cleanup = {}             # suite -> package
        cmdline = Cmdline()
        kernel_rc = re.compile('^linux.*$')
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            results['releases'] = {}
            if self.cfg['archive-versions']:
                #-----------------------------------------------------------------------------
                # Go through the archive data and find all the relevant series and packages
                # and thier versions. Seed the results dictionary with this information.
                #
                m = map_release_number_to_ubuntu_release
                for num in sorted(m.iterkeys(), key=lambda x:m[x]['name']):
                    if not m[num]['supported']:
                        continue

                    series      = m[num]['name']
                    series_pkgs = m[num]['packages']
                    results['releases'][series] = {}

                    # Add any versions from the ppa
                    #
                    for ppa_entry in self.ppa:
                        if self.ppa[ppa_entry]['series'] != series:
                            continue

                        sp     = self.ppa[ppa_entry]['source_package_name']
                        pocket = 'ppa'
                        spv    = self.ppa[ppa_entry]['source_package_version']
                        if sp not in results['releases'][series]:
                            results['releases'][series][sp] = {}
                        results['releases'][series][sp][pocket] = spv

                    # Add all the versions from the archive
                    #
                    for archive_entry in self.dversions:
                        if self.dversions[archive_entry]['series'] != series:
                            continue

                        sp     = self.dversions[archive_entry]['source_package_name']
                        pocket = self.dversions[archive_entry]['pocket']
                        spv    = self.dversions[archive_entry]['source_package_version']
                        if sp not in results['releases'][series]:
                            results['releases'][series][sp] = {}
                        results['releases'][series][sp][pocket] = spv

            #-----------------------------------------------------------------------------
            # Now go through all the packages that are currently in proposed and pull out
            # the bug (and any other) information.
            #


            for rls in self.release:
                self.dbg('core', "Release: '%s'\n" % (rls))
                for component in self.components:
                    self.dbg('core', "    Component: '%s'\n" % (component))

                    release  = self.tagfile_to_dict('%s/dists/%s/%s/source/Sources.gz'          % (self.archive_root, rls, component))
                    proposed = self.tagfile_to_dict('%s/dists/%s-proposed/%s/source/Sources.gz' % (self.archive_root, rls, component))
                    updates  = self.tagfile_to_dict('%s/dists/%s-updates/%s/source/Sources.gz'  % (self.archive_root, rls, component))
                    security = self.tagfile_to_dict('%s/dists/%s-security/%s/source/Sources.gz' % (self.archive_root, rls, component))

                    for package in sorted(proposed.keys()):
                        if 'linux' != package[:5]: continue
                        self.dbg('core', "        Package: '%s'\n" % (package))
                        update_ver = updates.get(package, '')
                        if apt_pkg.version_compare(proposed[package], update_ver) > 0:
                            security_ver = security.get(package, '')
                            pending.setdefault(rls, {})[package] = (release.get(package, ''), proposed[package], update_ver, security_ver)

                            #security_ver = security.get(package, '')
                            #if apt_pkg.version_compare(proposed[package], security_ver) < 0:
                            #    security_superseded.setdefault(rls, {})[package] = (proposed[package], security_ver)
                        else:
                            cleanup.setdefault(rls, []).append(package)

            # Pending Ubuntu Stable Release Updates
            #
            for rls in self.release:
                if rls not in results['releases']:
                    results['releases'][rls] = {}
                if rls in pending:
                    pkgs = pending[rls].keys()
                    for pkg in pkgs:
                        lpurl = 'https://launchpad.net/ubuntu/%s/+source/%s/' % (rls, pkg)
                        (vrel, vprop, vupd, vsec) = pending[rls][pkg]

                        (date, bugs) = self.get_changelog_info(lpurl+vprop)
                        age = int((time.time()-time.mktime(date))/86400)

                        if pkg not in results['releases'][rls]:
                            results['releases'][rls][pkg] = {}

                        if 'Release' not in results['releases'][rls][pkg]:
                            results['releases'][rls][pkg]['Release' ] = vrel
                        if 'Proposed' not in results['releases'][rls][pkg]:
                            results['releases'][rls][pkg]['Proposed'] = vprop
                        if 'Updates' not in results['releases'][rls][pkg]:
                            results['releases'][rls][pkg]['Updates' ] = vupd
                        if 'Security' not in results['releases'][rls][pkg]:
                            results['releases'][rls][pkg]['Security' ] = vupd
                        results['releases'][rls][pkg]['url'     ] = lpurl
                        results['releases'][rls][pkg]['age'     ] = age
                        results['releases'][rls][pkg]['bugs'    ] = {}

                        for bug in bugs:
                            results['releases'][rls][pkg]['bugs'][bug] = {}
                            try:
                                lp_bug = self.service.get_bug(bug)
                                state = 'missing'
                                if   'kernel-tracking-bug'          in lp_bug.tags: state = 'release-tracker'
                                elif 'kernel-release-tracker'       in lp_bug.tags: state = 'release-tracker'
                                elif 'kernel-release-tracking-bug'  in lp_bug.tags: state = 'release-tracker'
                                elif 'kernel-cve-tracker'           in lp_bug.tags: state = 'cve-tracker'
                                elif 'kernel-cve-tracking-bug'      in lp_bug.tags: state = 'cve-tracker'

                                # By making these checks separately and after the previous ones, we
                                # can add the correct state for tracking bugs.
                                #
                                if 'verification-failed-%s' % rls in lp_bug.tags: state = 'failed'
                                elif 'verification-done-%s'   % rls in lp_bug.tags: state = 'verified'
                                elif 'verification-needed-%s' % rls in lp_bug.tags: state = 'needed'

                                if 'hw-specific' in lp_bug.tags:
                                    attrib = '(hw)'

                                results['releases'][rls][pkg]['bugs'][bug]['title'] = lp_bug.title
                                results['releases'][rls][pkg]['bugs'][bug]['owner'] = lp_bug.owner.display_name
                                results['releases'][rls][pkg]['bugs'][bug]['state'] = state

                                results['releases'][rls][pkg]['bugs'][bug]['tags']  = []
                                for t in lp_bug.tags:
                                    results['releases'][rls][pkg]['bugs'][bug]['tags'].append(t)
                            except:
                                results['releases'][rls][pkg]['bugs'][bug]['title'] = "--- Error accessing this bugs Launchpad information. Possibly private?"
                                results['releases'][rls][pkg]['bugs'][bug]['owner'] = "unknown"
                                results['releases'][rls][pkg]['bugs'][bug]['state'] = "unknown"
                                results['releases'][rls][pkg]['bugs'][bug]['tags']  = []

            results['updated'] = datetime.utcnow().strftime("%A, %d. %B %Y %H:%M UTC")
            print json.dumps(results, sort_keys=True, indent=4)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle ommand line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = SruReport()
    app.main()

# vi:set ts=4 sw=4 expandtab:

