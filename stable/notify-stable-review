#!/usr/bin/env python
#

from os                                 import getenv, listdir, system
from sys                                import argv
from getopt                             import getopt, GetoptError
from commands                           import getstatusoutput
from tempfile                           import NamedTemporaryFile, mkdtemp
from shutil                             import move, rmtree
from string                             import whitespace, digits
from ktl.utils                          import stdo, error, eout, run_command
from ktl.std_app                        import StdApp
from ktl.git                            import Git, GitError
from ktl.kernel                         import Kernel

# *** You may remove this comment block from your application
#
# This script is a template for applications which provides common
# functionality, command line, processing, and use of configuration
# files. In order to create a new script, run:
#
# init-script <class-name> <script-name>
#
# using the name of the script you'd like to create and the name
# for the main class wrapper inside it.
#
# *** You may remove this comment block from your application

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error(e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo("  This utility is intended to be run after a set of stable patches are ready for review      \n")
        stdo("  inside an stable upstream kernel process. It looks at a git branch with patches for        \n")
        stdo("  review, and sends a notification email for the start of the review, plus all the patches as\n")
        stdo("  a response to the notification email. For more information, see:                           \n")
        stdo("  http://wiki.ubuntu.com/Kernel/Dev/ExtendedStable/Maintenance                               \n")
        stdo("                                                                                             \n")
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--dry-run] [--from=<email address>]                                              \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --dry-run        Run in test mode and do not really send out any mail. This will     \n")
        stdo("                         also cause the mail bodies to be written to stdout.                 \n")
        stdo("                                                                                             \n")
        stdo("        --from=<email address>                                                               \n")
        stdo("                         Sets the sender of the notification email. Without this option,     \n")
        stdo("                         the script tries to get this info from DEBFULLNAME and DEBEMAIL     \n")
        stdo("                         environment variables by default.                                   \n")
        stdo("                                                                                             \n")
        stdo("        --previous_release=<version tag or commit>                                           \n")
        stdo("                         The tag or commit of the top of the previous stable release, eg.    \n")
        stdo("                         v3.5.7, we will get the stable patches from that up to HEAD.        \n")
        stdo("                                                                                             \n")
        stdo("        --new_version=<version string>                                                       \n")
        stdo("                         The version for the set of stable patches in review to be released. \n")
        stdo("                         It's the new version to be displayed in subject/body of the email   \n")
        stdo("                         announcement sent out, eg. 3.6.6                                    \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --dry-run --previous_release=v3.5.7 --new_version=3.5.7-ext.1                     \n" % self.cfg['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'dry-run', 'from=', 'previous_release=', 'new_version=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--dry-run'):
                    self.cfg['dry-run'] = True

                elif opt in ('--from'):
                    self.cfg['from'] = val

                elif opt in ('--previous_release'):
                    self.cfg['previous_release'] = val

                elif opt in ('--new_version'):
                    self.cfg['new_version'] = val

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        """
        Used to verify that all required parameters are present and correct.
        """
        if 'previous_release' not in self.cfg:
            raise CmdlineError('--previous_release=<ref> must be specified.')
        if 'new_version' not in self.cfg:
            raise CmdlineError('--new_release=<str> must be specified.')
        return

mail_message = ("\n"
"I am announcing the review cycle for the %s release of stable patches.\n"
"This new release contains %s patches. Proposed patches are posted as a\n"
"response to this message. The same patches are also available at the\n"
"following repository:\n"
"\n"
"git://kernel.ubuntu.com/ubuntu/linux.git linux-%s.y-review\n"
"\n"
"If there are any problems, or if anything is missing, please answer to\n"
"this or to any of the followup patches. Note that any answer should be\n"
"made at maximum in 3 days, after that the final release of %s will be\n"
"made.\n"
"\n"
"See below the diffstat and shortlog for this release.\n"
"\n"
"-%s\n"
"\n"
"-- \n")

# AppTemplate
#
class AppTemplate(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        self.debug_run = False
        self.tolist = [
            "linux-kernel@vger.kernel.org",
            "stable@vger.kernel.org",
            "kernel-team@lists.ubuntu.com"
        ]
        return

    # function to add headers to the patches
    #
    def modify_patch(self, patch, version):
        header_line = "%s -stable review patch.  If anyone has any objections, please let me know." % (version)
        from_line = None
        subject = False
        header_add = False
        header_added = False
        with open(patch, 'r') as src:
            with NamedTemporaryFile(dir='./', delete=False) as dst:
                for line in src:
                    if header_added:
                        dst.write(line)
                        continue

                    # save to move from_line after header
                    if line.startswith("From:"):
                        from_line = line
                        continue

                    # strip out date
                    if line.startswith("Date:"):
                        continue

                    if not subject:
                        if 'Subject:' in line:
                            subject = True

                    if subject and not header_add:
                        if line.strip() == '':
                            header_add = True
                            continue

                    if header_add:
                        dst.write('\n')
                        dst.write(header_line)
                        dst.write('\n\n------------------\n\n')
                        if from_line:
                            dst.write(from_line)
                            dst.write('\n')
                        header_added = True

                    dst.write(line)
                temp = dst.name
        move(temp, patch)

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            # Check: Are we currently in a git repository?
            if not Git.is_repo():
                raise GitError('This script can only be run from within a git repository.')

            # Try to get the default name and email address to make up the sender
            # from the environment.
            sender = ""
            if not 'from' in self.cfg:
                sender_name  = getenv("DEBFULLNAME")
                sender_email = getenv("DEBEMAIL")
                if sender_email:
                    if sender_name:
                        sender = "%s <%s>" % (sender_name, sender_email)
                    else:
                        sender = sender_email
                else:
                    raise CmdlineError("Unable to determine the sender for the "
                                       "email (From: address). Set your "
                                       "DEBFULLNAME/DEBEMAIL properly or use "
                                       "the --from option")
            else:
                sender = self.cfg['from']

            # Get and validate kernel version
            kver = [ "", "", "", "" ]
            with open('Makefile', 'r') as mf:
                for line in iter(mf):
                    val = None
                    idx = -1
                    tot = 0
                    t = line.translate(None, whitespace)
                    if t.startswith("VERSION="):
                        idx = 0
                    elif t.startswith("PATCHLEVEL="):
                        idx = 1
                    elif t.startswith("SUBLEVEL="):
                        idx = 2
                    elif t.startswith("EXTRAVERSION="):
                        idx = 3
                    if idx >= 0:
                        val = line.split('=', 1)[-1]
                        kver[idx] = val.strip()
                        tot += 1
                        if tot > 3:
                            break
            if not (kver[0] and kver[1] and kver[2]):
                raise Exception("Invalid kernel version in Makefile")
            # Increment release number
            # XXX: disabled, uneeded...
            #if kver[3]:
            #    d = 1
            #    while kver[3][-d] in digits:
            #        d += 1
            #    if d > 1:
            #        d -= 1
            #        prx = kver[3][0:len(kver[3])-d]
            #        num = int(kver[3][-d:]) + 1
            #        kver[3] = prx + str(num)
            #else:
            #    kver[2] = str(int(kver[2])+1)
            # Get the base version
            if kver[0] == "1" or kver[1] == "2":
                base_ver = "%s.%s.%s.y" % (kver[0], kver[1], kver[2])
            else:
                base_ver = "%s.%s.y" % (kver[0], kver[1])
            ann_ver = "%s-ext.z" % base_ver

            old_head = self.cfg['previous_release']
            new_ver = self.cfg['new_version']

            # Get the number of patches, diffstat and shortlog from
            # previous release
            status, result = run_command("git log --no-merges "
                                         "--format=%%h %s.. | wc -l" %
                                        (old_head), self.debug_run)
            if status != 0:
                raise GitError("\n".join(result))
            patch_cnt = result[0]
            status, diffstat = getstatusoutput("git diff --stat %s.." %
                                               (old_head))
            if status != 0:
                raise GitError(diffstat)
            status, shortlog = getstatusoutput("git shortlog %s.." %
                                               (old_head))
            if status != 0:
                raise GitError(shortlog)

            # Create emails and send them
            tmpdir = mkdtemp()
            status, result = run_command("git format-patch -o %s %s.." %
                                         (tmpdir, old_head))
            if status != 0:
                rmtree(tmpdir)
                raise GitError("\n".join(result))
            patches = listdir(tmpdir)
            for patch in patches:
                self.modify_patch(tmpdir + "/" + patch, new_ver)
            mailbody = "From: " + sender + '\n'
            for entry in self.tolist:
                mailbody += "To: " + entry + '\n'
            mailbody += ("Subject: [%s extended stable] Linux %s stable review"
                         % (ann_ver, new_ver) + "\n")
            mailbody += mail_message % (new_ver, patch_cnt, base_ver,
                                        new_ver, sender.split()[0])
            mailbody += diffstat + '\n\n'
            mailbody += shortlog
            tf = NamedTemporaryFile(prefix="mail-")
            tf.write(mailbody)
            tf.flush()
            cmd = "git send-email --no-chain-reply-to --thread "
            cmd += "--from \"" + sender + "\""
            for line in self.tolist:
                cmd += " --to \"" + line + "\""
            if 'dry-run' in self.cfg:
                cmd += " --dry-run"
            cmd += " --8bit-encoding UTF-8"
            cmd += " " + tf.name + " " + tmpdir + "/*.patch"
            system(cmd)
            if 'dry-run' in self.cfg:
                print "\n\n" + mailbody
            tf.close()
            rmtree(tmpdir)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        except GitError as e:
            eout(e.msg)

        return

if __name__ == '__main__':
    app = AppTemplate()
    app.main()

# vi:set ts=4 sw=4 expandtab:

