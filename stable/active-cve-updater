#!/usr/bin/env python
#

from sys                                import argv
from os                                 import path
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, error
from ktl.std_app                        import StdApp
from lpltk.LaunchpadService             import LaunchpadService, LaunchpadServiceError
from re                                 import match

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}
        self.cfg['verbose'] = False
        self.cfg['debug']   = []

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>] --bug=<bug-id> --active=<path to active file> \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("        --staging        Use the staging LP server to create the bug. This is just for       \n")
        stdo("                         testing and will go away when the database is reset.                \n")
        stdo("                                                                                             \n")
        stdo("        --bug                                                                                \n")
        stdo("                                                                                             \n")
        stdo("        --active                                                                             \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'debug=', 'bug=', 'active=', 'staging']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif opt in ('--bug'):
                    self.cfg['cve-tracking-bug'] = val

                elif opt in ('--active'):
                    self.cfg['cve-active-file'] = val

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):

        if 'cve-tracking-bug' not in self.cfg:
            raise CmdlineError('A bug id must be specified on the command line.')

        if 'cve-active-file' not in self.cfg:
            raise CmdlineError('The full path to the cve-tracker-database active file associated with the CVE must be specified.')

        if not path.exists(self.cfg['cve-active-file']):
            raise CmdlineError('The specified active file (%s) does not exist.' % self.cfg['cve-active-file'])

        return


# ActiveCveUpdaterError
#
# A general exception that can be raised when an error is encountered in the app.
#
class ActiveCveUpdaterError(Exception):
    # __init__
    #
    def __init__(self, error=''):
        self.msg = error

# ActiveCveUpdater
#
class ActiveCveUpdater(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

    # initialize
    #
    def initialize(self):
        self.defaults['launchpad_client_name'] = 'kernel-team-active-cve-updater'
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        try:
            self.lp = LaunchpadService(self.defaults)
        except LaunchpadServiceError, e:
            print(e.msg)
            raise

    # verbose_bug_info
    #
    def verbose_bug_info(self, bug):
        if self.cfg['verbose']:
            print('      CVE tracking bug: %s' % self.cfg['cve-tracking-bug'])
            print('    CVE active db file: %s' % self.cfg['cve-active-file'])

            print(" ")
            print("    %s: %s" % (bug.id, bug.title))
            print(" ")

            tags = ""
            for t in bug.tags:
                tags += t
                tags += " "
            print("        Tags:")
            print("            %s" % (tags))

            tasks = bug.tasks
            print("        Tasks:")
            for task in tasks:
                print("            %45s %20s %20s" % (task.bug_target_name, task.status, task.importance))

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)
            self.initialize()

            try:
                bug = self.lp.get_bug(self.cfg['cve-tracking-bug'])

                self.verbose_bug_info(bug)

                tasks = bug.tasks
                for task in tasks:
                    m = match('^(.*) \(Ubuntu *(.*)\)$', task.bug_target_name)
                    if m != None:
                        pkg    = m.group(1)
                        series = m.group(2)

                        series_pkg = "%s_%s" % (series.lower(), pkg)
                        print(series_pkg)
                    else:
                        print('(%s)' % task.bug_target_name)
                        raise ActiveCveUpdaterError("Failed to matche the task.bug_target_name with the regular expression being used.")

            except:
                raise ActiveCveUpdaterError("The bug specified on the command line (%s) was not found in LaunchPad." % self.cfg['cve-tracking-bug'])

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = ActiveCveUpdater()
    app.main()

# vi:set ts=4 sw=4 expandtab:

