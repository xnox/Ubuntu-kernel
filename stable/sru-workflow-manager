#!/usr/bin/env python
#
# shank is the "stable bot" or "stab-bot".
#

from sys                                import argv
from os                                 import path
from getopt                             import getopt, GetoptError
from ktl.check_component                import CheckComponent
from ktl.utils                          import stdo, date_to_string
from ktl.ubuntu                         import Ubuntu
from ktl.std_app                        import StdApp
from ktl.workflow                       import Properties
from ktl.tracking_bug                   import TrackingBug
from lpltk.LaunchpadService             import LaunchpadService
from datetime                           import datetime
from urllib                             import quote
from urllib2                            import HTTPError
from ktl.messaging                      import Email, Status
from ktl.bugs                           import DeltaTime
import re
import traceback

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --bugs=<bug list>  Only process the included bugs                                    \n")
        stdo("                                                                                             \n")
        stdo("        --dry-run         Don't actually change any bugs, just print info.                   \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("        --staging                                                                            \n")
        stdo("                         Use the staging LP service instead of the production one.           \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=', 'staging', 'dry-run', 'bugs=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif (opt == '--dry-run'):
                    self.cfg['dryrun'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in '--bugs':
                    buglist = []
                    for bugnum in val.split(','):
                        buglist.append(bugnum)
                    self.cfg['buglist'] = buglist

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return

# Shank
#
class Shank(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

        self.state_map = {
            # Task, Current State, Action
            'prepare-package'         : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'upload-to-ppa'           : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.upload_to_ppa_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.upload_to_ppa_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lbm'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_lbm_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lrm'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_lrm_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-lum'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_lum_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-meta'    : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_meta_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-ports-meta':{'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_ports_meta_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'prepare-package-signed'   : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':self.prep_signed_package_in_progress},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-proposed'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.promote_to_proposed_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'verification-testing'    : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.verification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'certification-testing'   : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':self.certification_testing_invalid},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.certification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'regression-testing'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.regression_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-updates'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.check_for_final_close},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-security'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.check_for_final_close},
                                         'Unknown' : {'action':None},
                                         },
            'security-signoff'        : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':self.security_signoff_finished},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.security_signoff_finished},
                                         'Unknown' : {'action':None},
                                         },
        } 

    # initialize
    #
    def initialize(self):
        self.defaults['launchpad_client_name'] = 'kernel-team-sru-workflow-manager'
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        self.lp = LaunchpadService(self.defaults)
        self.ubuntu = Ubuntu()

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions['ubuntu']

        self.projectname = 'kernel-sru-workflow'

        self.project = self.lp.projects[self.projectname]

        # Get set up for email and status messages
        if 'mail_notify' in self.cfg:
            mcfg = self.cfg['mail_notify']
            self.email = Email(mcfg['smtp_server'].encode('UTF-8'), mcfg['smtp_user'].encode('UTF-8'), mcfg['smtp_pass'].encode('UTF-8'))

        scfg = self.cfg['status_net']
        self.status = Status(scfg['url'], scfg['user'], scfg['pass'])

        # Get the text for spamming bugs
        spamtextpath =  path.join(path.dirname(__file__), self.cfg['bug_spam']['text_filename'])
        self.verbose('Bug spam text is from file %s\n' % spamtextpath)
        self.spamtext = open(spamtextpath, 'r').read()

        self.taskbyname = {}

        self.printlink = "(No link)"

        return

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            # set our config file, which can be overridden on the command line
            self.defaults['configuration_file'] = path.dirname(__file__) + '/sru-workflow.cfg'
            #print('config file = %s' % self.defaults['configuration_file'])

            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            project = self.lp.projects[self.projectname]

            # Searching for bug tasks, the search can be quite complicated and made up
            # of several components. The following can be combined in many ways to get
            # the search you want. The search happens on the server and returns a
            # collection of bug tasks that match the search criteria.
            #
            # tasks = pkg.search_tasks(tags=search_tags, tags_combinator=search_tags_combinator,
            #                          status=self.cfg['task_search_status'], modified_since=search_since)
            #
            search_tags            = [   # A list of the tags we care about
                    'kernel-release-tracking-bug'
                ]
            search_tags_combinator = "All"
            search_status          = ["New","In Progress","Invalid", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
            search_since           = datetime(year=2011, month=1, day=1)
            tasks = project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

            for task in tasks:
                bug = task.bug
                if 'buglist' in self.cfg:
                    if str(bug.id) not in self.cfg['buglist']:
                        continue
                if 'staging' in self.cfg:
                    self.cfg['lpserver'] = 'bugs.qastaging.launchpad.net'
                else:
                    self.cfg['lpserver'] = 'bugs.launchpad.net'

                self.printlink =  '%s : (%s)\n' % (bug.id, self.bug_url(bug.id)),
                self.verbose('Processing: %s' % self.printlink)

                # initialize any per-bug variables that we use for the release test
                self.bugtags = []
                for atag in bug.tags:
                    self.bugtags.append(atag)
                performReleaseTest = False
                self.certification_testing_complete = False
                self.regression_testing_complete = False
                self.security_signoff_complete = False
                self.security_publishing_required = False

                # Initialize the properties object
                self.props = Properties(bug)
                #
                # list any Properties from bug description
                props = bug.properties
                for prop in props:
                    self.verbose('    Bug has Property:  %s:%s' % (prop, props[prop]))

                # We iterate through tasks on a bug but we need access to the other tasks, so first build a list up from of all tasks on this bug
                # TODO This is a bit sloppy and I should probably build one list and walk it twice.
                try:
                    # TODO revisit this, but hardcode for now
                    #mtstring = self.project.display_name
                    mtstring = self.projectname

                    self.taskbyname = {}
                    for t in bug.tasks:
                        task_name       = t.bug_target_name

                        if task_name == mtstring:
                            # we save a pointer to the master task and check to make sure we should process this bug
                            self.taskbyname[mtstring] = t
                            if t.status == 'In Progress':
                                continue
                            else:
                                self.verbose('    Not processing this bug because master task state is set to %s\n' % (t.status))
                                raise RuntimeError

                        if not task_name.startswith(mtstring):
                            # Ignore the tasks assigned to the actual package, we care about workflow only
                            self.verbose('Skipping non-workflow task <%s>:<%s>\n' % (mtstring, task_name))
                            continue

                        # add one to account for the trailing /
                        therest = task_name[len(mtstring)+1:].strip()
                        self.taskbyname[therest] = t

                except RuntimeError:
                    # end processing for this bug
                    self.verbose('    Quitting this bug\n')
                    continue

                # now walk them one at a time
                for t in bug.tasks:
                    task_name = t.bug_target_name.strip()
                    # bug_target_name includes both the main and sub task in the string
                    # so for example it could be "Kernel SRU Workflow prepare-package"
                    # so we have to strip off the right hand part
                    # The task can also be just the single parent task
                    #

                    if task_name == mtstring:
                        self.verbose('Skipping empty master workflow task \n')
                        continue

                    if not task_name.startswith(mtstring):
                        # Ignore the tasks assigned to the actual package, we care about workflow only
                        self.verbose('Skipping non-workflow task %s\n' % (task_name))
                        continue

                    therest = task_name[len(mtstring)+1:].strip()
                    task_name = therest

                    state      = t.status
                    importance = t.importance
                    assignee    = t.assignee
                    if assignee is None:
                        assignee = '*Unassigned'
                    else:
                        assignee = assignee.display_name

                    self.verbose("TASK: %25s  %15s  %10s  %s\n" % (task_name, state, importance, assignee))

                    if task_name not in self.state_map:
                        print self.printlink,
                        print("I don't know how to handle the task <%s>, skipping" % (task_name))
                        continue

                    if 'action' not in self.state_map[task_name][state]:
                        print self.printlink,
                        print("ERROR: No action found for state <%s> and task <%s>" % (state, task_name))
                        raise ValueError

                    action = self.state_map[task_name][state]['action']

                    if  action is None:
                        self.verbose('ACTION: No action for task %s in state %s\n' % (task_name, state))
                    else:
                        if action(t):
                            performReleaseTest = True

                # Now process any tests which require information from multiple tasks
                # will require info stored in class variables during task processing
                if performReleaseTest:
                    self.perform_release_test()

                # Now flush any property changes to the bug description
                self.props.flush()
                self.verbose('--\n')


        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

    # end of main

    def bug_url(self, bug_id):
        retval = 'https://%s/bugs/%s' % (self.cfg['lpserver'], bug_id)
        return retval

    def send_comment(self, task, subject, body):
        """
        Add comment to tracking bug
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Adding comment to tracking bug\n')
        else:
            self.verbose('Adding comment to tracking bug\n')
            task.bug.add_comment(body, subject)

    def send_email(self, task, subject, body, to_address=None):
        """
        Send email to the configured list or recipient
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Sending email\n')
            return

        self.verbose('Sending email\n')

        if not 'mail_notify' in self.cfg:
            self.verbose('No mail_notify config found, can\'t send email\n')
            return

        mcfg = self.cfg['mail_notify']
        if not to_address:
            to_address = mcfg['to_address']
        body_top = 'The following message is regarding the following Kernel SRU Tracking bug:\n%s\n' % self.bug_url(task.bug.id)
        body_top = body_top + ('%s\n\n' % task.bug.title)
        msg = body_top + body
        subj =  '[ShankBot] ' + subject
        self.email.send(mcfg['from_address'], to_address, subj, msg)
        return

    def send_status_update(self, task, message):
        """
        Send a status update to twitter, status.net, identi.ca, etc
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Sending Status\n')
            return

        self.verbose('Sending Status\n')

        bugurl = quote(self.bug_url(task.bug.id))

        btitle = task.bug.title
        packagename = btitle.split(':')[0]
        version = btitle.split(':')[1].split()[0]
        kinfo = self.ubuntu.lookup(version.split('-')[0])
        series_name = kinfo['name']
        pkgid = '%s package %s %s ' % (series_name, packagename, version)

        self.status.update(bugurl + ' : ' + pkgid + ' ' + message)
        return

    def set_task_to_state(self, taskname, state):
        """
        Set a task with a given name to the desired state
        returns True if we changed the state and False if it was already at the desired state
        """
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Set task %s to state %s\n' % (taskname, state))
            return

        # TODO could add error handling and retries here if needed
        if self.taskbyname[taskname].status != state:
            print self.printlink,
            print 'Setting Task <%s> to State <%s>' % (taskname, state)
            self.taskbyname[taskname].status = state
            return True
        else:
            self.verbose('Task <%s> was already in state <%s>\n' % (taskname, state))
            return False

    # set_tagged_timestamp
    #
    """
    Add the supplied key with a timestamp. We do not replace existing keys
    """
    def set_tagged_timestamp(self, taskobj, keyvalue):
        bug = taskobj.bug
        if keyvalue in  bug.properties:
            self.verbose('tagged timestamp <%s> already in the tracking bug, not replacing\n' % keyvalue)
            return
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Adding tagged timestamp <%s> to tracking bug\n' % keyvalue)
            return
        else:
            self.verbose('Adding tagged timestamp <%s> to tracking bug\n' % keyvalue)

            now = datetime.utcnow()
            now.replace(tzinfo=None)
            tstamp = date_to_string(now)
            props = {keyvalue:tstamp}
            self.props.set(props)

    # set_stable_phase
    #
    """
    Add the phase we're entering as a 'property',
    along with a time stamp
    """
    def set_stable_phase(self, taskobj, phasetext):
        # We have to check here to see whether the same status is already set,
        # or we will overwrite the timestamp needlessly
        if 'kernel-stable-phase' in taskobj.bug.properties:
            if taskobj.bug.properties['kernel-stable-phase'] == phasetext:
                # we already have this one
                self.verbose('Not overwriting identical phase property\n')
                return
        # Handle dryrun mode
        if 'dryrun' in self.cfg:
            self.verbose('Dryrun - Changing stable phase to <%s>\n' % phasetext)
            return
        else:
            self.verbose('Changing stable phase to <%s>\n' % phasetext)
        # Add phase and time stamp
        now = datetime.utcnow()
        now.replace(tzinfo=None)
        tstamp = date_to_string(now)
        props = {'kernel-stable-phase':phasetext, 'kernel-stable-phase-changed':tstamp}
        self.props.set(props)

    def is_prep_pkg_closed(self, taskname):
        if taskname in self.taskbyname:
            if (self.taskbyname[taskname].status != "Fix Released" and
                self.taskbyname[taskname].status != "Invalid"):
                return False
        return True

    def is_prep_pkg_released(self, taskname):
        if taskname in self.taskbyname:
            if self.taskbyname[taskname].status != "Fix Released":
                return False
        return True

    def get_dep_pkg_name(self, pkg_name, pkg_ver, deptype):
        series = self.ubuntu.series_name(pkg_name, pkg_ver)
        if not series:
            print("ERROR: Can't find series for %s-%s to check %s dependency\n" %
                  (pkg_name, pkg_ver, deptype))
            return None
        kinfo = self.ubuntu.lookup(series)
        if 'dependent-packages' in kinfo:
            if pkg_name in kinfo['dependent-packages']:
                if deptype in kinfo['dependent-packages'][pkg_name]:
                    return kinfo['dependent-packages'][pkg_name][deptype]
        print("ERROR: can't find %s package name for %s-%s\n" %
              (deptype, pkg_name, pkg_ver))
        return None

    def check_dep_pkg_built(self, taskobj, deptype):
        title = taskobj.bug.title
        pkg_name = re.findall('linux[^:]*', title)[0]
        pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
        dep_name = self.get_dep_pkg_name(pkg_name, pkg_ver, deptype)
        if not dep_name:
            return False
        pkg_abi = re.findall('-[0-9]+[^.]+', pkg_ver)[0]
        pkg_kernel = re.findall('-[0-9]+[^ ]+', pkg_ver)[0]
        pkg_kernel = pkg_ver.replace(pkg_kernel, '', 1)
        pkg_abi = pkg_abi.lstrip('-')
        dep_ver1 = '%s-%s' % (pkg_kernel, pkg_abi)
        dep_ver2 = '%s.%s' % (pkg_kernel, pkg_abi)
        ckt = self.lp.launchpad.people['canonical-kernel-team']
        ppa = ckt.getPPAByName(name='ppa')
        dep_matches = []
        for p in ppa.getPublishedSources(source_name=dep_name):
            src_ver = p.source_package_version
            # special case for hardy lrm version...
            if (deptype == 'lrm') and (pkg_kernel == '2.6.24'):
                if src_ver.startswith('2.6.24'):
                    ver_split = src_ver.split('-', 1)
                    if len(ver_split) > 1:
                        src_ver = '2.6.24-%s' % (ver_split[1])
            if ((p.status.lower() == 'published') and
                (src_ver.startswith(dep_ver1) or
                 src_ver.startswith(dep_ver2))):
                dep_matches.append(p)
        if not dep_matches:
            self.verbose('Can\'t find <%s> (<%s> or <%s>) build on c-k-t ppa\n' %
                         (dep_name, dep_ver1, dep_ver2))
        for dep_pkg in dep_matches:
            src_id = str(dep_pkg.self).rsplit('/', 1)[1]
            build_summaries = ppa.getBuildSummariesForSourceIds(source_ids=[src_id])[src_id]
            task_name = taskobj.bug_target_name
            workflow_task = task_name[len(self.projectname)+1:].strip()
            if build_summaries['status'] == 'FULLYBUILT':
                self.verbose('<%s> <%s> built, %s is Fix Released\n'
                             % (dep_name, dep_pkg.source_package_version, workflow_task))
                self.set_task_to_state(workflow_task, 'Fix Released')
            else:
                self.verbose('<%s> <%s> not fully built yet, %s still In Progress\n'
                             % (dep_name, dep_pkg.source_package_version, workflow_task))
        return False

    #
    # Begin action methods for state transitions
    #

    def prep_lbm_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-lbm task and it's set to In
        Progress, the package have a dependent linux-backports-modules
        package to be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'lbm')
        return False

    def prep_lrm_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-lrm task and it's set to In
        Progress, the package have a dependent linux-restricted-modules
        package to be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'lrm')
        return False

    def prep_lum_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-lum task and it's set to In
        Progress, the package have a dependent linux-ubuntu-modules
        package to be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'lum')
        return False

    def prep_meta_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-meta task and it's set to In
        Progress, the package have a dependent meta package to be built;
        update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'meta')
        return False

    def prep_ports_meta_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-ports-meta task and it's set to
        In Progress, the package have a dependent ports-meta package to
        be built; update the task if package is built
        """
        self.check_dep_pkg_built(taskobj, 'ports-meta')
        return False

    def is_pkg_built(self, pkg_name, pkg_ver):
        ckt = self.lp.launchpad.people['canonical-kernel-team']
        ppa = ckt.getPPAByName(name='ppa')
        matches = [ p for p in ppa.getPublishedSources(source_name=pkg_name)
                            if p.status.lower() == 'published' and
                               p.source_package_version == pkg_ver ]
        if not matches:
            self.verbose('Can\'t find <%s> <%s> build on c-k-t ppa\n' % (pkg_name, pkg_ver))
            return False
        for pkg in matches:
            src_id = str(pkg.self).rsplit('/', 1)[1]
            build_summaries = ppa.getBuildSummariesForSourceIds(source_ids=[src_id])[src_id]
            if build_summaries['status'] == 'FULLYBUILT':
                self.verbose('<%s> <%s> built\n'
                             % (pkg_name, pkg_ver))
                return True
            else:
                self.verbose('<%s> <%s> not fully built yet, skipping\n'
                             % (pkg_name, pkg_ver))
        return False

    def prep_signed_package_in_progress(self, taskobj):
        """
        when we have a prepare-package-signed task and it's set to
        In Progress, the package have a dependent signed package to
        be built; update the task if package is built
        """
        title = taskobj.bug.title
        pkg_name = re.findall('linux[^:]*', title)[0]
        pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
        dep_name = self.get_dep_pkg_name(pkg_name, pkg_ver, 'signed')
        if dep_name and self.is_pkg_built(dep_name, pkg_ver):
            self.set_task_to_state('prepare-package-signed', 'Fix Released')
        return False

    def prep_package_in_progress(self, taskobj):
        """
        when the prep-package task is set to In Progress and no
        upload-to-ppa task is present, kernel team builds the packages;
        check the build status and update tasks
        """
        task_name = taskobj.bug_target_name
        workflow_task = task_name[len(self.projectname)+1:].strip()
        if ('upload-to-ppa' in self.taskbyname and workflow_task == 'prepare-package'):
            return False
        if (not (self.is_prep_pkg_closed('prepare-package-lbm') and
                 self.is_prep_pkg_closed('prepare-package-lrm') and
                 self.is_prep_pkg_closed('prepare-package-lum') and
                 self.is_prep_pkg_closed('prepare-package-meta') and
                 self.is_prep_pkg_closed('prepare-package-ports-meta') and
                 self.is_prep_pkg_closed('prepare-package-signed'))):
            return False
        title = taskobj.bug.title
        pkg_name = re.findall('linux[^:]*', title)[0]
        pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
        if self.is_pkg_built(pkg_name, pkg_ver):
            if not 'upload-to-ppa' in self.taskbyname:
                self.set_task_to_state('prepare-package', 'Fix Released')
            else:
                self.set_task_to_state('upload-to-ppa', 'Fix Released')
        return False

    def prep_package_fix_released(self, taskobj):
        """
        when the prep-package task is set to Fix Released and there is
        no upload-to-ppa task, we create new tracking bugs for
        derivative packages, and set the promote-to-proposed task to
        Confirmed. Otherwise, if upload-to-ppa task is present, just set
        it to Confirmed if necessary
        """
        task_name = taskobj.bug_target_name
        workflow_task = task_name[len(self.projectname)+1:].strip()
        if ('upload-to-ppa' in self.taskbyname and workflow_task == 'prepare-package'):
            if self.taskbyname['upload-to-ppa'].status == 'New':
                self.set_task_to_state('upload-to-ppa', 'Confirmed')
            return False

        if self.taskbyname['promote-to-proposed'].status == 'New':
            # open new tracking bugs for derivative packages if needed
            title = taskobj.bug.title
            pkg_name = re.findall('linux[^:]*', title)[0]
            pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
            series = self.ubuntu.series_name(pkg_name, pkg_ver)
            if not series:
                print("ERROR: Can't find series for %s-%s to get derivatives\n"
                      % (pkg_name, pkg_ver))
                return False
            der_list = []
            found = self.ubuntu.lookup(series)
            if 'derivative-packages' in found:
                if pkg_name in found['derivative-packages']:
                    der_list = found['derivative-packages'][pkg_name]
            bp_list = []
            for entry in self.ubuntu.db.itervalues():
                if 'backport-packages' in entry:
                    bp_entries = entry['backport-packages']
                    for bp_entry in iter(bp_entries):
                        if (bp_entries[bp_entry][0] == pkg_name and
                            bp_entries[bp_entry][1] == found['series_version']):
                            bp_list.append([bp_entry, entry['name']])
            der_bug_list = []
            bp_bug_list = []
            m_bug_list = []
            msgder =  "This tracking bug was opened to be worked from "
            msgder += "%s-%s update (bug %s)" % (pkg_name, pkg_ver, taskobj.bug.id)
            subder =  "Derivative package tracking bug"
            tb = TrackingBug(self.lp, 'staging' in self.cfg)
            for der_pkg in der_list:
                if 'dryrun' in self.cfg:
                    self.verbose('Dryrun - Would open tracking bug for derivative package %s\n'
                                 % (der_pkg))
                    continue
                try:
                    bug = tb.open(der_pkg, '<version to be filled>', True, series)
                except:
                    traceback.print_exc()
                    bug = None
                if bug:
                    bug.add_comment(msgder, subder)
                    print 'Opened tracking bug %s for derivative package %s\n' % (bug.id, der_pkg)
                    der_bug_list.append([der_pkg, bug.id])
                else:
                    m_bug_list.append('%s' % (der_pkg))
            for bp_pkg in bp_list:
                if 'dryrun' in self.cfg:
                    self.verbose('Dryrun - Would open tracking bug for backport package %s\n'
                                 % (bp_pkg[0]))
                    continue
                # Verify abi change, assume all prepare-package-* tasks are Fix Released
                new_abi = (self.is_prep_pkg_released('prepare-package-lbm') and
                           self.is_prep_pkg_released('prepare-package-lrm') and
                           self.is_prep_pkg_released('prepare-package-lum') and
                           self.is_prep_pkg_released('prepare-package-meta') and
                           self.is_prep_pkg_released('prepare-package-ports-meta'))
                try:
                    bug = tb.open(bp_pkg[0], '%s~%s1' % (pkg_ver, bp_pkg[1]), new_abi)
                except:
                    traceback.print_exc()
                    bug = None
                if bug:
                    print('Opened tracking bug %s for backport package %s (%s)\n'
                          % (bug.id, bp_pkg[0], bp_pkg[1]))
                    bp_bug_list.append([bp_pkg[0], bp_pkg[1], bug.id])
                else:
                    m_bug_list.append('%s (%s)' % (bp_pkg[0], bp_pkg[1]))

            # comment about publishing and possible new tracking bugs opened
            msgbody  = 'All builds are complete, packages in this bug can be'
            msgbody += ' copied to -proposed.'
            if der_bug_list:
                msgbody += '\n\nDerivative packages from packages here can be worked on,'
                msgbody += ' the following tracking bugs were opened for them:'
                for pkg_bug in der_bug_list:
                    msgbody += '\n%s - bug %s' % (pkg_bug[0], pkg_bug[1])
            if bp_bug_list:
                msgbody += '\n\nBackport packages from packages here can be worked on,'
                msgbody += ' the following tracking bugs were opened for them:'
                for pkg_bug in bp_bug_list:
                    msgbody += '\n%s (%s) - bug %s' % (pkg_bug[0], pkg_bug[1], pkg_bug[2])
            if m_bug_list:
                msgbody += '\n\nIt was not possible to create or handle the'
                msgbody += ' tracking bugs for the following packages'
                msgbody += ' (their tracking bugs based on this update'
                msgbody += ' must be handled manually):'
                for ln in m_bug_list:
                    msgbody += '\n%s' % (ln)
            task = self.taskbyname[self.projectname]
            self.send_comment(task, 'Packages are ready for -proposed', msgbody)

            # Set promote-to-proposed
            self.set_task_to_state('promote-to-proposed', 'Confirmed')
            # Add time stamp and status
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Prepare-package-end')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Promote-to-proposed-start')
            self.set_stable_phase(taskobj, 'CopyToProposed')
        return False

    def upload_to_ppa_in_progress(self, taskobj):
        """
        When the upload-to-ppa task is set to In Progress, kernel team
        builds the packages; check the build status and update tasks
        """
        return self.prep_package_in_progress(taskobj)

    def upload_to_ppa_fix_released(self, taskobj):
        """
        When the upload-to-ppa task is set to Fix Released we create new
        tracking bugs for derivative packages, and set the
        promote-to-proposed task to Confirmed.
        """
        return self.prep_package_fix_released(taskobj)

    def has_prep_task(self, taskname):
        if taskname in self.taskbyname:
            if self.taskbyname[taskname].status == "Fix Released":
                return True
        return False

    def promote_to_proposed_fix_released(self, taskobj):
        """
        When promote-to-proposed is set to Fix Released, we begin verification testing by setting
        verification-testing to In Progress, add tags to the bugs, and spam with text
        """
        # Exit if processed already
        task = self.taskbyname['verification-testing']
        if task.status != 'New':
            return False

        # Set promote-to-proposed timestamp first, used for checking below
        self.set_tagged_timestamp(taskobj, 'kernel-stable-Promote-to-proposed-end')

        # Wait publishing tasks to complete. Usually archive admin sets
        # the promote-to-proposed task to Fix Released right away after
        # doing the copy, but actual publishing takes more time. It's
        # said that the publishing should take at most 1 hour to
        # complete, but could be a bit more in some cases, or could
        # vary. Anyway, just wait arbitrarily 1 hour before we do the
        # actual processing, to avoid sru-workflow-manager to complain
        # about packages in wrong component while real copying/publishing
        # still didn't finish, in the case the packages were previously
        # in the wrong component and are now moved to the right ones.
        bug = taskobj.bug
        if 'kernel-stable-Promote-to-proposed-end' in bug.properties:
            date_str = bug.properties['kernel-stable-Promote-to-proposed-end']
            timestamp = datetime.strptime(date_str, '%A, %d. %B %Y %H:%M UTC')
            delta = DeltaTime(timestamp, datetime.utcnow())
            if delta.hours < 1:
                self.verbose('Waiting 1 hour after promote-to-proposed was Fix Released\n')
                return False
        else:
            return False

        # Check if packages were copied to the right pocket->component
        title = bug.title
        pkg_name = re.findall('linux[^:]*', title)[0]
        pkg_ver = re.findall('([0-9]+\.[^ ]+)', title)[0]
        series_name = self.ubuntu.series_name(pkg_name, pkg_ver)
        check_component = CheckComponent(self.lp)
        name_meta = 'linux-meta'
        name_ports_meta = 'linux-ports-meta'
        name_split = pkg_name.split('-', 1)
        if len(name_split) > 1:
            name_meta = '%s-meta-%s' % (name_split[0], name_split[1])
            name_ports_meta = '%s-ports-meta-%s' % (name_split[0], name_split[1])
        name_map = { 'prepare-package-lbm' : 'linux-backports-modules',
                     'prepare-package-lrm' : 'linux-restricted-modules',
                     'prepare-package-lum' : 'linux-ubuntu-modules',
                     'prepare-package-meta' : name_meta,
                     'prepare-package-ports-meta' : name_ports_meta }
        ver_split = pkg_ver.split('-')
        main_version = ver_split[0]
        pkg_list = [ pkg_name ]
        for name in iter(name_map):
            if self.has_prep_task(name):
                if ('lbm' in name) or ('lrm' in name) or ('lum' in name):
                    pkg_list.append('%s-%s' % (name_map[name], main_version))
                else:
                    pkg_list.append(name_map[name])
        missing_pkg = []
        pkg_abi = ''
        dep_ver1 = main_version
        dep_ver2 = main_version
        if len(ver_split) > 1:
            pkg_abi = ver_split[1].split('.')[0]
            dep_ver1 = '%s-%s' % (main_version, pkg_abi)
            dep_ver2 = '%s.%s' % (main_version, pkg_abi)
        mis_lst = []
        for pkg in pkg_list:
            if pkg == pkg_name:
                check_ver = pkg_ver
            else:
                check_ver = None
            ps = check_component.get_published_sources(series_name, pkg,
                                                       check_ver, 'proposed')
            if not ps:
                if check_ver:
                    missing_pkg.append([pkg, check_ver])
                else:
                    missing_pkg.append([pkg, 'with ABI=%s' % (pkg_abi)])
                continue
            if not check_ver:
                src_ver = ps[0].source_package_version
                # special hardcoded case for lrm on hardy...
                if pkg == 'linux-restricted-modules-2.6.24':
                    src_split = src_ver.split('-')
                    if src_split[0].startswith(main_version) and len(src_split) > 1:
                        src_ver = '%s-%s' % (main_version, src_split[1])
                if src_ver.startswith(dep_ver1) or src_ver.startswith(dep_ver2):
                    mis_lst.extend(check_component.mismatches_list(series_name,
                                   pkg, ps[0].source_package_version,
                                   'proposed', ps))
                else:
                    missing_pkg.append([pkg, 'with ABI=%s' % (pkg_abi)])
            else:
                mis_lst.extend(check_component.mismatches_list(series_name,
                               pkg, check_ver, 'proposed', ps))
        if not missing_pkg:
            if mis_lst:
                self.set_task_to_state('promote-to-proposed', 'Incomplete')
                msgbody  = "The following packages ended up in the wrong"
                msgbody += " component in the -proposed pocket:\n"
                for item in mis_lst:
                    msgbody += '\n%s %s - is in %s instead of %s' % (item[0],
                               item[1], item[2], item[3])
                bugbody = msgbody
                bugbody += "\n\nOnce this is fixed, set the "
                bugbody += "promote-to-proposed to Fix Released again"
                self.send_comment(task, 'Packages outside of main', bugbody)
                if not 'dryrun' in self.cfg:
                    self.props.set({'kernel-stable-Promote-to-proposed-end':None})
                self.send_email(task, '[bug %s] Packages copied to the wrong component'
                                % (task.bug.id), msgbody)
                return False
        else:
            # Even if we already waited 1 hour, wait more (1 day) before
            # complaining if we don't find the packages published to
            # -proposed, in case the copy/publishing take more hours
            # after promote-to-proposed is set to Fix Released the first
            # time
            if delta.days >= 1:
                self.set_task_to_state('promote-to-proposed', 'Incomplete')
                msgbody  = "Promote-to-proposed is Fix Released, but "
                msgbody += "some packages for this update aren't published "
                msgbody += "in Launchpad, on -proposed pocket:\n"
                for item in missing_pkg:
                    msgbody += '\n%s %s' % (item[0], item[1])
                self.send_comment(task, 'Can\'t find packages published in -proposed', msgbody)
                if not 'dryrun' in self.cfg:
                    self.props.set({'kernel-stable-Promote-to-proposed-end':None})
                return False
            for item in missing_pkg:
                self.verbose('Didn\'t found <%s> <%s> on -proposed yet, check on next run\n'
                             % (item[0], item[1]))
            return False

        # Update remaining time stamps and status
        self.set_task_to_state('verification-testing', 'In Progress')
        self.set_tagged_timestamp(taskobj, 'kernel-stable-Verification-testing-start')
        self.set_stable_phase(taskobj, 'Verification')
        # Now tag all bugs verification-needed and spam with a comment
        # Automate this in the future but for now send an email
        print self.printlink,
        print 'Here is where we would tag and spam the verification bugs'
        return False

    def verification_testing_fix_released(self, taskobj):
        """
        When verification-testing is set to Fix Released, we set three tasks to Confirmed.
        These are certification-testing, regression-testing, and security-signoff
        """
        # Add time stamp and status
        if ((self.taskbyname['certification-testing'].status != 'Fix Released' and
             self.taskbyname['certification-testing'].status != 'Invalid') or
            (self.taskbyname['security-signoff'].status != 'Fix Released' and
             self.taskbyname['security-signoff'].status != 'Invalid') or
            self.taskbyname['regression-testing'].status != 'Fix Released'):
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Verification-testing-end')
            self.set_stable_phase(taskobj, 'Testing')

        if self.taskbyname['certification-testing'].status == 'New':
            self.set_task_to_state('certification-testing', 'Confirmed')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-start')
        if self.taskbyname['regression-testing'].status == 'New':
            self.set_task_to_state('regression-testing', 'Confirmed')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Regression-testing-start')
        if self.taskbyname['security-signoff'].status == 'New':
            self.set_task_to_state('security-signoff', 'Confirmed')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Security-signoff-start')
        return False

    def certification_testing_fix_released(self, taskobj):
        """
        When certification-testing is set to Fix Released, we check the tags
        If tagged certification-testing-failed then we alert people
        If certification-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'certification-testing-failed' in self.bugtags:
            self.verbose('Certification tagged as FAIL\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-end')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as certification-testing-failed\n'
            self.send_comment(taskobj, 'Certification FAILURE', msgbody)
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')
            self.set_stable_phase(taskobj, 'TestFail')
            return False
        elif 'certification-testing-passed' in self.bugtags:
            self.verbose('Certification tagged as PASSED\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-end')
            # TODO send a status.net update?
            self.certification_testing_complete = True
            return True
        else:
            self.verbose('certification-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The certification-testing task was set to Fix Released but neither the certification-testing-passed or certification-testing-failed tag was applied\n'
            self.send_comment(taskobj, 'Certification completed but no status tags applied', msgbody)
            # reset task state so Certification team fixes it
            self.set_task_to_state('certification-testing', 'Incomplete')
            return False

    def certification_testing_invalid(self, taskobj):
        """
        When certification-testing is set to Invalid, this indicates
        that certification testing will not be performed on this release.
        We consider the task to be 'done' in that we trigger a release test,
        but we don't check any tags
        """
        self.certification_testing_complete = True
        self.set_tagged_timestamp(taskobj, 'kernel-stable-Certification-testing-end')
        return True

    def regression_testing_fix_released(self, taskobj):
        """
        When regression-testing is set to Fix Released, we check the tags
        If tagged qa-testing-failed then we alert people
        If qa-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'qa-testing-failed' in self.bugtags:
            self.verbose('Regression Testing tagged as FAIL\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Regression-testing-end')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as qa-testing-failed\n'
            self.send_comment(taskobj, 'Regression Testing FAILURE', msgbody)
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')
            self.set_stable_phase(taskobj, 'TestFail')
            return False
        elif 'qa-testing-passed' in self.bugtags:
            self.verbose('Regression Testing tagged as PASSED\n')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Regression-testing-end')
            # TODO send a status.net update?
            self.regression_testing_complete = True
            return True
        else:
            self.verbose('regression-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The regression-testing task was set to Fix Released but neither the qa-testing-passed or qa-testing-failed tag was applied\n'
            self.send_comment(taskobj, 'Regression Testing completed but no status tags applied', msgbody)
            # reset task so QA team can fix it
            self.set_task_to_state('regression-testing', 'Incomplete')
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')
            self.set_stable_phase(taskobj, 'OnHold')
            return False

    def security_signoff_finished(self, taskobj):
        """
        When security-signoff is set to either Invalid or Fix Released, it is done.
        If set to Fix Released, we set a flag to indicate that the package must
        be copied to the -security pocket.
        """
        self.security_signoff_complete = True
        self.set_tagged_timestamp(taskobj, 'kernel-stable-Security-signoff-end')
        # Trigger the release test
        return True

    def release_test_state_check(self, taskname, desired_state_list):
        taskobj = self.taskbyname[taskname]
        if taskobj.status not in desired_state_list:
            self.verbose('ERROR: %s task set to Unexpected state!\n' % taskname)
            # Send email and possibly a status update
            msgbody = 'The %s task was not set to one of the following states during the release test:\n' % taskname
            for statename in desired_state_list:
                msgbody = msgbody + statename + ', '
            msgbody = msgbody + '\n'
            msgbody = msgbody + '%s task was set to state %s\n' % (taskname, taskobj.status)
            msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
            self.send_comment(taskobj, '%s task not set to correct state during release test' % taskname, msgbody)
            # stop further processing by this bot
            self.set_task_to_state(self.projectname, 'Incomplete')

    def hold_updates_security_copy(self):
        """
        The security team wants to avoid updates being copied to
        security/updates on Friday before the weekend. If there is some
        last minute crisis/regression on the kernel copied to
        -updates/-security, there are little resources to deal with this
        on the weekend. Also USN processing may be affected the by time
        of the kernel release. It was agreed that we should delay kernel
        copying to -updates/-security if we are between 1800UTC Fri -
        2100UTC Sun, this function is used to check that so we delay
        setting the promote to -updates/-security tasks to Confirmed.
        """
        now = datetime.utcnow()
        wday = now.weekday()
        if wday == 5:
            return True
        if wday == 4 and now.hour >= 18:
            return True
        if wday == 6 and now.hour < 21:
            return True
        return False

    #
    # This is not performed during processing for a specific task but only if several tasks are
    # in the correct state
    #
    # perform_release_test
    #
    def perform_release_test(self):
        """
        Check results from multiple tasks to see whether release
        to -updates and -security are required
        """
        self.verbose('*** Performing release test\n')

        # No need to do anything until these three are all complete
        if (self.certification_testing_complete and self.regression_testing_complete and self.security_signoff_complete):
            self.verbose('Cert and regression testing and security signoff all complete\n')

            # Some general sanity checks before we pull the lever to publish
            self.release_test_state_check('prepare-package', ['Fix Released'])
            self.release_test_state_check('promote-to-proposed', ['Fix Released'])
            self.release_test_state_check('verification-testing', ['Fix Released'])
            self.release_test_state_check('certification-testing', ['Invalid', 'Fix Released'])
            self.release_test_state_check('regression-testing', ['Fix Released'])
            self.release_test_state_check('security-signoff', ['Invalid', 'Fix Released'])
            # confirmed is in the next two in case we rerun the release test after
            # a dumb failure like email send fail or something
            self.release_test_state_check('promote-to-security', ['New', 'Confirmed', 'Invalid', 'Fix Released'])
            self.release_test_state_check('promote-to-updates', ['New', 'Confirmed', 'Fix Released'])

            # If we found any problems, we've halted processing and set this
            if self.taskbyname[self.projectname].status != 'In Progress':
                self.verbose('*** Exiting release test without triggering any publishing\n')
                return

            if ((self.taskbyname['promote-to-security'].status == 'Confirmed' or
                 self.taskbyname['promote-to-security'].status == 'Invalid') and
                self.taskbyname['promote-to-updates'].status == 'Confirmed'):
                self.verbose('*** Exiting release test, all set\n')
                return

            if self.taskbyname['security-signoff'].status == 'Fix Released':
                # publishing to security is required
                self.security_publishing_required = True

            # one last check for test results
            if 'qa-testing-passed' in self.bugtags and \
                    ('certification-testing-passed' in self.bugtags or self.taskbyname['certification-testing'].status == 'Invalid'):

                # No publication on Fri/Sat/Sun (see function)
                if not self.hold_updates_security_copy():
                    task = self.taskbyname[self.projectname]
                    # we're all good
                    if self.security_publishing_required:
                        self.verbose('Requires publishing to the -security pocket\n')
                        if self.taskbyname['promote-to-security'].status == 'New':
                            self.set_task_to_state('promote-to-security', 'Confirmed')
                    else:
                        if self.taskbyname['promote-to-security'].status == 'New':
                            self.set_task_to_state('promote-to-security', 'Invalid')

                    if self.taskbyname['promote-to-updates'].status == 'New':
                        self.set_task_to_state('promote-to-updates', 'Confirmed')
                        self.set_tagged_timestamp(task, 'kernel-stable-Promote-to-updates-start')
                        self.set_stable_phase(task, 'CopyToUpdates')
                    # Now send a happy email 
                    msgbody = 'All tests are complete and the publishing tasks have been set to Confirmed\n'
                    #self.send_email(task, 'Package is ready for publication', msgbody)
                    #self.send_status_update(task, 'available for publication.')
                else:
                    self.verbose('Avoiding to touch publishing tasks on Fri/Sat/Sun\n')
                
            else:
                # don't have required testing signoffs
                self.verbose('ERROR: test completion tags not found during release test!\n')
                # Send email and possibly a status update
                msgbody = 'During the release test either the certification-testing-passed or the qa-testing-passed tag was not found\n'
                msgbody = msgbody + 'Tags on this bug are:\n'
                for ftag in self.bugtags:
                    msgbody = msgbody + '    ' + ftag + '\n'
                msgbody = msgbody + '\n'
                msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
                self.send_comment(self.taskbyname[self.projectname], 'Test completion tags not found during release test', msgbody)
                # stop further processing by this bot
                self.set_task_to_state(self.projectname, 'Incomplete')
                self.set_stable_phase(task, 'OnHold')
        # this method is not associated with a task state transition so no status returned
        return 

    def check_for_final_close(self, taskobj):
        """
        If either of the publishing tasks is set to complete (Fix Released) we
        make a check to see whether we can set the entire tracking bug to Fix Released (done)
        """
        self.verbose('*** Performing check for final close test\n')

        if (( self.taskbyname['promote-to-updates'].status == 'Fix Released') and
            (self.taskbyname['promote-to-security'].status == 'Invalid' or
            self.taskbyname['promote-to-security'].status == 'Fix Released')):

            print self.printlink,
            print ' Everything is done, setting bug to Fix Released'
            self.set_task_to_state(self.projectname, 'Fix Released')
            self.set_tagged_timestamp(taskobj, 'kernel-stable-Promote-to-updates-end')
            self.set_stable_phase(taskobj, 'Released')

            # Send email and possibly a status update -spc- TODO
            msgbody = 'The package has been published and the bug is being set to Fix Released\n'
            self.send_comment(taskobj, 'Package Released!', msgbody)

            task = self.taskbyname['promote-to-updates']
            self.send_status_update(task, 'has been published.')

        # We should never trigger a release test from this, since it should have lready been done
        return False

if __name__ == '__main__':
    app = Shank()
    try:
        app.main()
    except HTTPError, err:
        if err.code == 503:
            print 'Launchpad server is down (503)'
        else:
            print 'Launchpad returned error %d' % err.code
            raise

# vi:set ts=4 sw=4 expandtab:

