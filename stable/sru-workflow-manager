#!/usr/bin/env python
#
# shank is the "stable bot" or "stab-bot".
#

from sys                                import argv
from os                                 import path, popen
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, error
from ktl.std_app                        import StdApp
from lpltk.service                      import LaunchpadService
from datetime                           import datetime
from urllib                             import quote
from urllib2                            import HTTPError
from ktl.messaging                      import Email, Status

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("        --staging                                                                            \n")
        stdo("                         Use the staging LP service instead of the production one.           \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=', 'staging']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return


# Shank
#
class Shank(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

        self.state_map = {
            # Task, Current State, Action
            'prepare-package'         : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.prep_package_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'upload-to-ppa'           : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-proposed'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.promote_to_proposed_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'verification-testing'    : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.verification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'certification-testing'   : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.certification_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'regression-testing'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.regression_testing_fix_released},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-updates'      : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'promote-to-security'     : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':None},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':None},
                                         'Unknown' : {'action':None},
                                         },
            'security-signoff'        : {'New' : {'action':None},
                                         'Incomplete' : {'action':None},
                                         'Opinion' : {'action':None},
                                         'Invalid' : {'action':self.security_signoff_finished},
                                         "Won't Fix" : {'action':None},
                                         'Expired' : {'action':None},
                                         'Confirmed' : {'action':None},
                                         'Triaged' : {'action':None},
                                         'In Progress' : {'action':None},
                                         'Fix Committed' : {'action':None},
                                         'Fix Released' : {'action':self.security_signoff_finished},
                                         'Unknown' : {'action':None},
                                         },
        } 

        # Meta-information for this script is tracked in the kernel-sru-workflow task
        #
        # kernel-sru-workflow Status: New               <- Just created
        #                     Status: In-progress       <- Actively monitored by the bot
        #                     Status: Incomplete        <- Something bad happened
        #                     Status: Invalid           <- Replaced by a new tracking bug
        #                     Status: Fix-Released      <- Everything went good, done!
        #
        #
        #
        # State transition listing
        #
        # https://wiki.ubuntu.com/Kernel/kernel-sru-workflow
        #
        # Tasks:
        #
        #   * prepare-package
        #         New -> 'In Progress' MANUAL When stable team begins package prep
        #               Triggers: nothing
        #         'In Progress' -> 'Fix Released' MANUAL when PPA builds are complete (future automation)
        #               Triggers: promote-to-proposed changes to 'Confirmed'
        #
        #   * upload-to-ppa - this state not used at this time
        #
        #   * promote-to-proposed
        #         'Confirmed' -> 'In Progress' MANUAL When archive admin takes the task
        #               Triggers: Nothing
        #         'In Progress' -> 'Fix Released' MANUAL when packages are in -proposed
        #               Triggers: verification-testing set to 'In Progress'
        #                         Affected bugs marked 'verification needed' and spammed with text
        #
        #   * verification-testing
        #         New -> 'In Progress' AUTO
        #               Triggers:Nothing
        #         'In Progress' -> 'Fix Released' MANUAL when all bugs are verified (future automation)
        #               Triggers: certification-testing, regression-testing, and security-signoff set to 'Confirmed'
        #
        #   * certification-testing
        #         New -> 'Confirmed' AUTO
        #               Triggers: Nothing
        #         'Confirmed' -> 'In Progress' MANUAL When someone takes the task
        #               Triggers: Nothing
        #         'In Progress' -> 'Fix Released' MANUAL when testing is complete
        #                           NOTE: certification-testing-passed or certification-testing-failed tag must be added
        #                                 BEFORE changing to Fix Released
        #               Triggers: Release Test
        #
        #   * regression-testing
        #         New -> 'Confirmed' AUTO
        #               Triggers: Nothing
        #         'Confirmed' -> 'In Progress' MANUAL When someone takes the task
        #               Triggers: Nothing
        #         'In Progress' -> 'Fix Released' MANUAL when testing is complete
        #                           NOTE: qa-testing-passed or qa-testing-failed tag must be added
        #               Triggers: Release Test
        #
        #   * security-signoff
        #         New -> 'Confirmed' AUTO
        #               Triggers: Nothing
        #         'Confirmed' -> 'In Progress' MANUAL When someone takes the task
        #               Triggers: Nothing
        #         'In Progress' -> 'Invalid' MANUAL if not required to be published to -security
        #               Triggers: Release Test
        #         'In Progress' -> 'Fix Released' MANUAL if publiching to -security required
        #               Triggers: Release Test
        #
        #   promote-to-updates
        #         New -> 'Confirmed' AUTO
        #               Triggers: Nothing
        #         'Confirmed' -> 'In Progress' MANUAL When archive admin takes the task
        #               Triggers: Nothing
        #         'In Progress' -> 'Fix Released' MANUAL when packages are in -updates
        #               Triggers: Nothing
        #
        #   promote-to-security
        #         New -> 'Confirmed' AUTO
        #               Triggers: Nothing
        #         'Confirmed' -> 'In Progress' MANUAL When archive admin takes the task
        #               Triggers: Nothing
        #         'In Progress' -> 'Fix Released' MANUAL when packages are in -security
        #               Triggers: Nothing
        #
        ######
        #
        # * 'Release Test' - triggered to be run by several states
        #
        #     IF -failed tag present for qa or cert, then TODO DO SOMETHING (email the SRU list?)
        #
        #     IF  certification-testing task and regression-testing tasks are both 'Fix Released'
        #     AND both those tasks have tags for -passed
        #     then:
        #        set promote-to-updates to 'Confirmed'
        #        IF security-signoff is 'Fix Released'
        #            set promote-to-security to 'Confirmed'
        #


    # initialize
    #
    def initialize(self):
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        self.lp = LaunchpadService(self.defaults)

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions['ubuntu']

        # Get set up for email and status messages
        mcfg = self.cfg['mail_notify']
        self.email = Email(mcfg['smtp_server'].encode('UTF-8'), mcfg['smtp_user'].encode('UTF-8'), mcfg['smtp_pass'].encode('UTF-8'))

        scfg = self.cfg['status_net']
        self.status = Status(scfg['url'], scfg['user'], scfg['pass'])

        # Get the text for spamming bugs
        spamtextpath =  path.join(path.dirname(__file__), self.cfg['bug_spam']['text_filename'])
        self.verbose('Bug spam text is from file %s\n' % spamtextpath)
        self.spamtext = open(spamtextpath, 'r').read()

        self.taskbyname = {}

        return

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            # set our config file, which can be overridden on the command line
            self.defaults['configuration_file'] = path.dirname(__file__) + '/sru-workflow.cfg'
            #print('config file = %s' % self.defaults['configuration_file'])

            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            project = self.lp.projects['kernel-sru-workflow']

            # Searching for bug tasks, the search can be quite complicated and made up
            # of several components. The following can be combined in many ways to get
            # the search you want. The search happens on the server and returns a
            # collection of bug tasks that match the search criteria.
            #
            # tasks = pkg.search_tasks(tags=search_tags, tags_combinator=search_tags_combinator,
            #                          status=self.cfg['task_search_status'], modified_since=search_since)
            #
            search_tags            = [   # A list of the tags we care about
                    'kernel-release-tracking-bug'
                ]
            search_tags_combinator = "All"
            search_status          = ["New","In Progress","Invalid", "Incomplete", "Fix Committed"] # A list of the bug statuses that we care about
            search_since           = datetime(year=2011, month=1, day=1)
            tasks = project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

            for task in tasks:
                bug = task.bug
                if 'staging' in self.cfg:
                    self.cfg['lpserver'] = 'bugs.qastaging.launchpad.net'
                else:
                    self.cfg['lpserver'] = 'bugs.launchpad.net'

                bugurl = 'https://%s/ubuntu/+source/linux/+bug/%s\n' % (self.cfg['lpserver'], bug.id)
                self.verbose('    Processing -> %s' % bugurl)

                # initialize any per-bug variables that we use for the release test
                self.bugtags = []
                for atag in bug.tags:
                    self.bugtags.append(atag)
                performReleaseTest = False
                self.certification_testing_complete = False
                self.regression_testing_complete = False
                self.security_signoff_complete = False
                self.security_publishing_required = False

                # We iterate through tasks on a bug but we need access to the other tasks, so first build a list up from of all tasks on this bug
                # TODO This is a bit sloppy and I should probably build one list and walk it twice.
                try:
                    for t in bug.tasks:
                        task       = t.bug_target_name
                        parts = task.split()
                        mastertask = parts[0]
                        if len(parts) == 1:
                            # we save a pointer to the master task and check to make sure we should process this bug
                            if mastertask == 'kernel-sru-workflow':
                                self.taskbyname[mastertask] = t
                                if t.status == 'In Progress':
                                    continue
                                else:
                                    self.verbose('    Not processing this bug because master task state is set to %s\n' % (t.status))
                                    raise RuntimeError
                        else:
                            task = parts[1]
                        self.taskbyname[task] = t
                except RuntimeError:
                    # end processing for this bug
                    self.verbose('    Quitting this bug\n')
                    continue

                # now walk them one at a time
                for t in bug.tasks:
                    task       = t.bug_target_name
                    # bug_target_name includes both the main and sub task in the string
                    # so for example it could be "kernel-sru-workflow prepare-package"
                    # so we have to strip off the right hand part
                    # The task can also be just the single parent task i.e. "kernel-sru-workflow"
                    parts = task.split()
                    mastertask = parts[0]

                    if len(parts) == 1:
                        if mastertask == 'kernel-sru-workflow':
                            self.verbose('Skipping empty master workflow task \n')
                            continue
                    else:
                        task = parts[1]

                    # Ignore the tasks assigned to the actual package, we care about workflow only
                    if mastertask != "kernel-sru-workflow":
                        #self.verbose('Skipping non-workflow task %s:%s\n' % (mastertask, task))
                        continue

                    state      = t.status
                    importance = t.importance
                    assignee    = t.owner.display_name
                    assignee    = t.assignee
                    if assignee is None:
                        assignee = '*Unassigned'
                    else:
                        assignee = assignee.display_name

                    self.verbose("TASK: %25s  %15s  %10s  %s\n" % (task, state, importance, assignee))

                    try:
                        taskstates = self.state_map[task]
                    except KeyError:
                        print "I don't know how to handle the task <%s>, skipping\n" % (task)
                        continue

                    # now call the processing method for this state and task.
                    try:
                        action = taskstates[state]['action']
                    except KeyError:
                        print("ERROR: No action found for state <%s> and task <%s>" % (state, task))
                        raise

                    if  action is None:
                        self.verbose('ACTION: No action for task %s in state %s\n' % (task, state))
                    else:
                        if action(t):
                            performReleaseTest = True

                # Now process any tests which require information from multiple tasks
                # will require info stored in class variables during task processing
                if performReleaseTest:
                    self.perform_release_test()
                        
                self.verbose('--\n')


        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

    # end of main

    def send_email(self, task, subject, body):
        """
        Send email to the configured list or recipient
        """
        self.verbose('Sending email\n')
        if 'staging' in self.cfg:
            bugurl = 'https://%s/ubuntu/+source/linux/+bug/%s\n' % (self.cfg['lpserver'], task.bug.id)
        else:
            bugurl = 'http://pad.lv/%s' % (task.bug.id)

        mcfg = self.cfg['mail_notify']
        body_top = 'The following message is regarding the following Kernel SRU Tracking bug:\n%s\n\n' % bugurl
        msg = body_top + body
        subj =  '[ShankBot] ' + subject
        self.email.send(mcfg['from_address'], mcfg['to_address'], subj, msg)
        return

    def send_status_update(self, task, message):
        """
        Send a status update to twitter, status.net, identi.ca, etc
        """
        self.verbose('Sending Status\n')
        if 'staging' in self.cfg:
            bugurl = 'https://%s/ubuntu/+source/linux/+bug/%s\n' % (self.cfg['lpserver'], task.bug.id)
        else:
            bugurl = 'http://pad.lv/%s' % (task.bug.id)

        bugurl = quote(bugurl)

        self.status.update(bugurl + ' : ' + message)
        return

    def set_task_to_state(self, taskname, state):
        """
        Set a task with a given name to the desired state
        returns True if we changed the state and False if it was already at the desired state
        """
        # TODO could add error handling and retries here if needed
        if self.taskbyname[taskname].status != state:
            self.verbose('Setting Task <%s> to State <%s>\n' % (taskname, state))
            self.taskbyname[taskname].status = state
            return True
        else:
            self.verbose('Task <%s> was already in state <%s>\n' % (taskname, state))
            return False

    #
    # Begin action methods for state transitions
    #

    def prep_package_fix_released(self, taskobj):
        """
        when the prep-package task is set to Fix Released, we set the
        promote-to-proposed task to Confirmed
        """
        if self.taskbyname['promote-to-proposed'].status == 'New':
            self.set_task_to_state('promote-to-proposed', 'Confirmed')
        return False

    def promote_to_proposed_fix_released(self, taskobj):
        """
        When promote-to-proposed is set to Fix Released, we begin verification testing by setting
        verification-testing to In Progress, add tags to the bugs, and spam with text
        """
        task = self.taskbyname['verification-testing']
        if task.status == 'New':
            if self.set_task_to_state('verification-testing', 'In Progress'):
                # we did change the state, weren't already in it
                # Now tag all bugs verification-needed and spam with a comment
                # Automate this in the future but for now send an email
                print 'Here is where we would tag and spam the verification bugs'
                msgbody = 'The stable kernel team should now add bug comments and tags\nas required. This is a manual step for now.'
                self.send_email(taskobj, 'Bug spamming required', msgbody)
                self.send_status_update(task, 'New kernel package packagename available in -proposed.')
        return False

    def verification_testing_fix_released(self, taskobj):
        """
        When verification-testing is set to Fix Released, we set three tasks to Confirmed.
        These are certification-testing, regression-testing, and security-signoff
        """
        if self.taskbyname['certification-testing'].status == 'New':
            self.set_task_to_state('certification-testing', 'Confirmed')
        if self.taskbyname['regression-testing'].status == 'New':
            self.set_task_to_state('regression-testing', 'Confirmed')
        if self.taskbyname['security-signoff'].status == 'New':
            self.set_task_to_state('security-signoff', 'Confirmed')
        return False

    def certification_testing_fix_released(self, taskobj):
        """
        When certification-testing is set to Fix Released, we check the tags
        If tagged certification-testing-failed then we alert people
        If certification-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'certification-testing-failed' in self.bugtags:
            self.verbose('Certification tagged as FAIL\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as certification-testing-failed\n'
            self.send_email(taskobj, 'Certification FAILURE', msgbody)
            # stop further processing by this bot
            self.set_task_to_state('kernel-sru-workflow', 'Incomplete')
            return False
        elif 'certification-testing-passed' in self.bugtags:
            self.verbose('Certification tagged as PASSED\n')
            # TODO send a status.net update?
            self.certification_testing_complete = True
            return True
        else:
            self.verbose('certification-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The certification-testing task was set to Fix Released but neither the certification-testing-passed or certification-testing-failed tag was applied\n'
            self.send_email(taskobj, 'Certification completed but no status tags applied', msgbody)
            # stop further processing by this bot
            self.set_task_to_state('kernel-sru-workflow', 'Incomplete')
            return False

    def regression_testing_fix_released(self, taskobj):
        """
        When regression-testing is set to Fix Released, we check the tags
        If tagged regression-testing-failed then we alert people
        If regression-testing-passed then we save the tag and state and trigger
        running of the test to see if we're ready for publishing
        """
        if 'regression-testing-failed' in self.bugtags:
            self.verbose('Regression Testing tagged as FAIL\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The bug was tagged as regression-testing-failed\n'
            self.send_email(taskobj, 'Regression Testing FAILURE', msgbody)
            # stop further processing by this bot
            self.set_task_to_state('kernel-sru-workflow', 'Incomplete')
            return False
        elif 'regression-testing-passed' in self.bugtags:
            self.verbose('Regression Testing tagged as PASSED\n')
            # TODO send a status.net update?
            self.regression_testing_complete = True
            return True
        else:
            self.verbose('regression-testing task set to Fix Released but no status tag!\n')
            # Send email and possibly a status update -spc- TODO
            msgbody = 'The regression-testing task was set to Fix Released but neither the regression-testing-passed or regression-testing-failed tag was applied\n'
            self.send_email(taskobj, 'Regression Testing completed but no status tags applied', msgbody)
            # stop further processing by this bot
            self.set_task_to_state('kernel-sru-workflow', 'Incomplete')
            return False

    def security_signoff_finished(self, taskobj):
        """
        When security-signoff is set to either Invalid or Fix Released, it is done.
        If set to Fix Released, we set a flag to indicate that the package must
        be copied to the -security pocket.
        """
        self.security_signoff_complete = True
        # Trigger the release test
        return True

    def release_test_state_check(self, taskname, desired_state_list):
        taskobj = self.taskbyname[taskname]
        if taskobj.status not in desired_state_list:
            self.verbose('ERROR: %s task set to Unexpected state!\n' % taskname)
            # Send email and possibly a status update
            msgbody = 'The %s task was not set to one of the following statesduring the release test:\n' % taskname
            for statename in desired_state_list:
                msgbody = msgbody + statename + ', '
            msgbody = msgbody + '\n'
            msgbody = msgbody + '%s task was set to state %s\n' % (taskname, taskobj.status)
            msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
            self.send_email(taskobj, '%s task not set to correct state during release test' % taskname, msgbody)
            # stop further processing by this bot
            self.set_task_to_state('kernel-sru-workflow', 'Incomplete')

    #
    # This is not performed during processing for a specific task but only if several tasks are
    # in the correct state
    #
    # perform_release_test
    #
    def perform_release_test(self):
        """
        Check results from multiple tasks to see whether release
        to -updates and -security are required
        """
        self.verbose('*** Performing release test')

        # No need to do anything until these three are all complete
        if (self.certification_testing_complete and self.regression_testing_complete and self.security_signoff_complete):
            self.verbose('Cert and regression testing and security signoff all complete\n')

            # Some general sanity checks before we pull the lever to publish
            self.release_test_state_check('prepare-package', ['Fix Released'])
            self.release_test_state_check('promote-to-proposed', ['Fix Released'])
            self.release_test_state_check('verification-testing', ['Fix Released'])
            self.release_test_state_check('certification-testing', ['Fix Released'])
            self.release_test_state_check('regression-testing', ['Fix Released'])
            self.release_test_state_check('security-signoff', ['Invalid', 'Fix Released'])
            # confirmed is in the next two in case we rerun the release test after
            # a dumb failure like email send fail or something
            self.release_test_state_check('promote-to-security', ['New', 'Confirmed', 'Invalid'])
            self.release_test_state_check('promote-to-updates', ['New', 'Confirmed'])

            # If we found any problems, we've halted processing and set this
            if self.taskbyname['kernel-sru-workflow'].status != 'In Progress':
                self.verbose('*** Exiting release test without triggering any publishing\n')
                return

            if self.taskbyname['security-signoff'].status == 'Fix Released':
                # publishing to security is required
                self.security_publishing_required = True

            # one last check for test results
            if 'regression-testing-passed' in self.bugtags and 'certification-testing-passed' in self.bugtags:
                # we're all good
                if self.security_publishing_required:
                    self.verbose('Requires publishing to the -security pocket\n')
                    if self.taskbyname['promote-to-security'].status == 'New':
                        self.set_task_to_state('promote-to-security', 'Confirmed')
                else:
                    if self.taskbyname['promote-to-security'].status == 'New':
                        self.set_task_to_state('promote-to-security', 'Invalid')

                if self.taskbyname['promote-to-updates'].status == 'New':
                    self.set_task_to_state('promote-to-updates', 'Confirmed')
                # Now send a happy email 
                msgbody = 'All tests are complete and the publishing tasks have been set to Confirmed\n'
                task = self.taskbyname['kernel-sru-workflow']
                self.send_email(task, 'Package is ready for publication', msgbody)
                self.send_status_update(task, 'Tested kernel package available for publication.')
                
            else:
                # don't have required testing signoffs
                self.verbose('ERROR: test completion tags not found during release test!\n')
                # Send email and possibly a status update
                msgbody = 'During the release test either the certification-testing-passed or the regression-testing-passed tag was not found\n'
                msgbody = msgbody + 'Tags on this bug are:\n'
                for ftag in self.bugtags:
                    msgbody = msgbody + '    ' + ftag + '\n'
                msgbody = msgbody + '\n'
                msgbody = msgbody + 'Further processing of this bug by Workflow Manager is halted.\n'
                self.send_email(self.taskbyname['kernel-sru-workflow'], 'Test completion tags not found during release test', msgbody)
                # stop further processing by this bot
                self.set_task_to_state('kernel-sru-workflow', 'Incomplete')
    
        # this method is not associated with a task state transition so no status returned
        return 

if __name__ == '__main__':
    app = Shank()
    try:
        app.main()
    except HTTPError, err:
        if err.code == 503:
            print 'Launchpad server is down (503)'
        else:
            print 'Launchpad returned error %d' % err.code
            raise

# vi:set ts=4 sw=4 expandtab:

