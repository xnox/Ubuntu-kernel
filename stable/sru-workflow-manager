#!/usr/bin/env python
#
# shank is the "stable bot" or "stab-bot".
#

from sys                                import argv
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, error
from ktl.std_app                        import StdApp
from lpltk.service                      import LaunchpadService
from datetime                           import datetime
from ktl.kernel                         import map_release_number_to_ubuntu_release as ubuntu_release_map

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': print e
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --verbose        Give some feedback of what is happening while the script is         \n")
        stdo("                         running.                                                            \n")
        stdo("                                                                                             \n")
        stdo("        --config=<cfg file>                                                                  \n")
        stdo("                         The full path to the configuration file to use instead of           \n")
        stdo("                         the default location.                                               \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("        --staging                                                                            \n")
        stdo("                         Use the staging LP service instead of the production one.           \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --verbose                                                                         \n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'config=', 'debug=', 'staging']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif opt in ('--config'):
                    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif (opt == '--staging'):
                    self.cfg['staging'] = True

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        return


# Shank
#
class Shank(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}

        self.task_map = {
            # who to assign to
            'certification-testing' : {'assignee':'New'},
            'upload-to-ppa'         : {'assignee':'New'},
            'promote-to-proposed'   : {'assignee':'New'},
            'promote-to-updates'    : {'assignee':'New'},
            'promote-to-security'   : {'assignee':'New'},
            'regression-testing'    : {'assignee':'New'},
            'security-signoff'      : {'assignee':'New'},
            'verification-testing'  : {'assignee':'New'},
            }
        

        self.state_map = {
            # Task, Current State, Action
            'kernel-sru-workflow'     : {'New' : {'action':None}}, # easier to put in the table with no actions than to special case
            'prepare-package'         : {'New' : {'action':None}, 'In Progress' : {'action':self.prep_package_in_progress}},
            'certification-testing'   : {'New' : {'action':None}},
            'upload-to-ppa'           : {'New' : {'action':None}},
            'promote-to-proposed'     : {'New' : {'action':None}},
            'promote-to-updates'      : {'New' : {'action':None}},
            'promote-to-security'     : {'New' : {'action':None}},
            'regression-testing'      : {'New' : {'action':None}},
            'security-signoff'        : {'New' : {'action':None}},
            'verification-testing'    : {'New' : {'action':None}},
        } 

    # initialize
    #
    def initialize(self):
        if 'staging' in self.cfg:
            self.defaults['launchpad_services_root'] = 'qastaging'
        self.lp = LaunchpadService(self.defaults)

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions['ubuntu']

        return

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            project = self.lp.projects['kernel-sru-workflow']

            # Searching for bug tasks, the search can be quite complicated and made up
            # of several components. The following can be combined in many ways to get
            # the search you want. The search happens on the server and returns a
            # collection of bug tasks that match the search criteria.
            #
            # tasks = pkg.search_tasks(tags=search_tags, tags_combinator=search_tags_combinator,
            #                          status=self.cfg['task_search_status'], modified_since=search_since)
            #
            search_tags            = [   # A list of the tags we care about
                    'kernel-release-tracking-bug'
                ]
            search_tags_combinator = "All"
            search_status          = ["New","Invalid","Fix Committed"] # A list of the bug statuses that we care about
            search_since           = datetime(year=2011, month=1, day=1)
            tasks = project.search_tasks(status=search_status, tags=search_tags, tags_combinator=search_tags_combinator, modified_since=search_since)

            for task in tasks:
                bug = task.bug
                self.verbose("    %s\n" % (bug.id))

                for t in bug.tasks:
                    task       = t.bug_target_name
                    state      = t.status
                    importance = t.importance
                    assignee    = t.owner.display_name
                    assignee    = t.assignee
                    if assignee == None:
                        assignee = '*Unassigned'
                    else:
                        assignee = assignee.display_name

                    # bug_target_name includes both the main and sub task in the string
                    # so for example it could be "kernel-sru-workflow prepare-package"
                    # so we have to strip off the right hand part
                    # The task can also be just the single parent task i.e. "kernel-sru-workflow"
                    parts = task.split()
                    mastertask = parts[0]
                    if len(parts) == 1:
                        if mastertask == 'kernel-sru-workflow':
                            self.verbose('Skipping empty master workflow task \n')
                            continue
                    else:
                        task = parts[1]

                    # Ignore the tasks assigned to the actual package, we care about workflow only
                    if mastertask != "kernel-sru-workflow":
                        #self.verbose('Skipping non-workflow task %s:%s\n' % (mastertask, task))
                        continue

                    self.verbose("TASK: %25s  %15s  %10s  %s\n" % (task, state, importance, assignee))

                    try:
                        taskstates = self.state_map[task]
                    except KeyError:
                        print "I don't know how to handle the task <%s>, skipping\n" % (task)
                        continue

                    # now call the processing method for this state and task.
                    try:
                        action = taskstates[state]['action']
                    except KeyError:
                        print("ERROR: No action found for state <%s> and task <%s>" % (state, task))
                        raise

                    if  action is None:
                        self.verbose('ACTION: No action for task %s in state %s\n' % (task, state))
                    else:
                        newstate = action(t)
                        self.verbose('ACTION: Action was taken to change task %s state from %s to %s\n' % (task, state, newstate))
                        
                self.verbose('--\n')

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

    #
    # Begin action methods for state transitions
    #

    # prep-package_in_progress
    #
    def prep_package_in_progress(self, taskobj):
        # This is where the tests and actions will be coded for each task and state

        print '*** In action method for in-progress/prep-package ***'
        # don't change anything right now
        return taskobj.status

if __name__ == '__main__':
    app = Shank()
    app.main()

# vi:set ts=4 sw=4 expandtab:

