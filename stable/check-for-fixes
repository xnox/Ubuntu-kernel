#!/usr/bin/env python
#

from sys                                import argv
from getopt                             import getopt, GetoptError
from ktl.utils                          import stdo, error, run_command, eout
from ktl.std_app                        import StdApp
from ktl.git                            import Git, GitError
from commands                           import getstatusoutput
from multiprocessing                    import Pool, Lock, Value
import re

# This script is intended to find possible fixes for regressions or
# other issues introduced by a set of commits on a given linux kernel
# tree. Usually regression/stable fixes references the previous commits
# by either the commit hash, subject, or both: this script looks for
# hashes/subjects cited on upstream commits, and prints the resulting
# output, so it can be manually checked if it's a relevant patch/fix
# that could be applied to the tree.

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error(e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [--verbose] [--config=<cfg file>] [--debug=<dbg options>]                         \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --base=<git rev>                                                                     \n")
        stdo("                         Git base revision or range of commits to check for citations        \n")
        stdo("                         in upstream commits.                                                \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("        --repo=<path to git upstream repository>                                             \n")
        stdo("                         Git repository to use as upstream source. If not specified,         \n")
        stdo("                         %s                                                                  \n" % defaults['git_repo_upstream'])
        stdo("                         is used by default                                                  \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --debug=cfg                                                                       \n" % self.cfg['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'verbose', 'base=', 'debug=', 'repo=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif opt in ('--base'):
                    self.cfg['base'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif opt in ('--repo'):
                    defaults['git_repo_upstream'] = val

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        """
        Used to verify that all required parameters are present and correct.
        """
        return

lock = Lock()
step = Value('d', 0)
total = 0
plist = []
def process_commit_check(line):
    global step
    global lock
    lock.acquire()
    step.value += 1
    stdo("\rChecking %d/%d commits..." % (step.value, total))
    lock.release()

    res = {}
    status, body = getstatusoutput('git log %s^..%s --format=%%B'
                                   % (line, line))
    if status != 0:
        raise GitError(body)
    body = body.replace('\n', ' ')
    for commit in plist:
        commit_rc = commit[0]
        subject_rc = commit[1]
        if commit_rc.search(body):
            res[commit_rc.pattern] = True
            continue
        if subject_rc.search(body):
            res[commit_rc.pattern] = True
    if res:
        return [ line, res ]
    else:
        return [ None, None ]

# CheckForFixes
#
class CheckForFixes(StdApp):
    debug_run = False

    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = { 'git_repo_upstream' : 'git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git' }

    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        self.debug_run = ('debug' in self.cfg) and ('run' in self.cfg['debug'])
        return

    def get_upstream_shas(self, sha, merge_base, end = None):
        picked = []
        pattern = re.compile(r'commit \b([a-fA-F0-9]+)\b', re.IGNORECASE)
        if not end:
            crange = '%s..' % (sha)
        else:
            crange = '%s..%s' % (sha, end)
        stdo("\rMatching local to upstream commits...")
        status, result = getstatusoutput('git log --format=%%B %s' % (crange))
        if status != 0:
            raise GitError(result)
        for match in pattern.finditer(result):
            status, commit = run_command('git log --format=%%h %s^..%s' %
                                         (match.group(1), match.group(1)),
                                         self.debug_run)
            if status != 0:
                continue
            picked.append(commit[0])
        status, subjects = run_command('git log --format=%%s %s' % (crange))
        if status != 0:
            raise GitError("\n".join(subjects))
        status, result = run_command('git log --format="%%h %%s" %s..FETCH_HEAD' % (merge_base))
        if status != 0:
            raise GitError("\n".join(result))
        r = 1
        stdo("\r%s" % (' ' * 80))
        for s in subjects:
            stdo("\rMatching subject to upstream sha (%d/%d)..." % (r, len(subjects)))
            src = re.compile(re.escape(s))
            for res in result:
                if src.search(res):
                    picked.append(res.split(' ')[0])
                break
            r += 1
        return picked

    # main
    #
    def main(self):
        global total
        global plist

        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            # Check: Are we currently in a git repository?
            if not Git.is_repo():
                raise GitError('This script can only be run from within a git repository.')

            # Identify the base commit
            sha = None
            end = None
            if not 'base' in self.cfg:
                commit_rc = re.compile('^commit\s+([a-f0-9]+)\s*$')
                ubuntu_rc = re.compile('^\s+UBUNTU: Ubuntu-.*')
                status, result = run_command("git log --pretty=short", self.debug_run)
                if status == 0:
                    commit = None
                    for line in result:
                        m = commit_rc.match(line)
                        if m:
                            commit = m.group(1)
                        m = ubuntu_rc.match(line)
                        if m:
                            sha = commit
                            break
                else:
                    raise GitError("\n".join(result))
                status, result = run_command("git rev-parse HEAD", self.debug_run)
                if status != 0:
                    raise GitError("\n".join(result))
                end = result[0]
            else:
                status, result = run_command('git log --reverse --format=%%H %s' %
                                             (self.cfg['base']), self.debug_run)
                if status != 0:
                    raise GitError("\n".join(result))
                end = result[len(result) - 1]
                status, result = run_command('git log -1 --format=%%H %s^'
                                             % (result[0]), self.debug_run)
                if status != 0:
                    raise GitError("\n".join(result))
                sha = result[0]
            if not sha:
                raise GitError('Unable to find last release commit.')

            # Fetch latest upstream changes
            status, result = run_command("git fetch -q %s master" %
                                         self.defaults['git_repo_upstream'],
                                         self.debug_run)
            if status != 0:
                raise GitError("\n".join(result))

            # Identify the point upstream and our tree diverged
            status, result = run_command('git merge-base HEAD FETCH_HEAD',
                                         self.debug_run)
            if status != 0:
                raise GitError("\n".join(result))
            merge_base = result[0]

            # Check if our end commit is from upstream branch
            status, result = run_command('git merge-base %s FETCH_HEAD' % (end),
                                         self.debug_run)
            if status != 0:
                raise GitError("\n".join(result))
            fast_forward = (end == result[0])

            # Extract hashes/subject from commits, convert to upstream
            # hashes if necessary
            clist = []
            if not fast_forward:
                status, merged = run_command('git log --format=%%h %s..%s' %
                                             (sha, merge_base), self.debug_run)
            else:
                status, merged = run_command('git log --format=%%h %s..%s' %
                                             (sha, end), self.debug_run)
            if status != 0:
                raise GitError("\n".join(merged))
            if not (merged and merged[0]):
                merged = []
            if not fast_forward:
                if merged:
                    picked = self.get_upstream_shas(merge_base, merge_base, end)
                    picked.extend(merged)
                else:
                    picked = self.get_upstream_shas(sha, merge_base, end)
            else:
                picked = merged
            for change in set(picked):
                status, subject = run_command('git log --format=%%s %s^..%s' %
                                              (change, change), self.debug_run)
                if status != 0:
                    raise GitError("\n".join(subject))
                clist.append([re.compile(change),
                              re.compile(re.escape(subject[0]))])

            if len(clist) == 0:
                raise GitError("No upstream commits by default, or in the range specified")

            # Match with upstream commits which mentions the stable patches
            if not fast_forward:
                status, result = run_command('git log --reverse --no-merges --format=%h HEAD..FETCH_HEAD',
                                             self.debug_run)
            else:
                status, result = run_command('git log --reverse --no-merges --format=%%h %s..FETCH_HEAD'
                                             % (end), self.debug_run)
            if status != 0:
                raise GitError("\n".join(result))
            stdo("\r%s" % (' ' * 80))
            plist.extend(clist)
            total = len(result)
            pool = Pool()
            poolres = pool.map(process_commit_check, result)
            results = dict(poolres)
            del results[None]

            # Try to filter out already applied fixes, or old fixes cited
            if not fast_forward:
                clist = self.get_upstream_shas(merge_base, merge_base)
            else:
                clist = []
            clist.extend(merged)

            r = 1
            stdo("\r%s" % (' ' * 80))
            for commit in clist:
                stdo("\rFiltering from %d/%d commits..." % (r, len(clist)))
                if commit in results:
                    del results[commit]
                r += 1

            # Print results
            print("\n")
            if results:
                for res in iter(results):
                    for cm in iter(results[res]):
                        print("Commit %s is referenced in %s" % (cm, res))
            else:
                print("No references found")

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle command line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        except GitError as e:
            eout(e.msg)

        return

if __name__ == '__main__':
    app = CheckForFixes()
    app.main()

# vi:set ts=4 sw=4 expandtab:

